/*! jQuery Browser - v0.1.0 - 3/23/2012
 * https://github.com/jquery/jquery-browser
 * Copyright (c) 2012 John Resig; Licensed MIT */
/*
	THIS IS A STRIPPED VERSION OF THE ORIGINAL LIBRARY!
*/
/* Modernizr 2.5.3 (Custom Build) | MIT & BSD
 * Build: http://www.modernizr.com/download/#-csstransforms3d-prefixed-teststyles-testprop-testallprops-prefixes-domprefixes
 */
/*!
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
/*! jQuery plugin for Hammer.JS - v1.1.3 - 2014-05-20
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */
/*
 * @name wowBook
 *
 * @author Marcio Aguiar
 * @version 1.0.9
 * @requires jQuery v1.7.0
 *
 * Copyright 2010 Marcio Aguiar. All rights reserved.
 *
 * To use this file you must to buy a license at http://codecanyon.net/user/maguiar01/portfolio
 *
 * Date: Wed Dec 8 10:05:49 2010 -0200
 */
(function(d) {
    if (!d.browser) {
        var p;
        p = navigator.userAgent || "";
        d.uaMatch = function(d) {
            d = d.toLowerCase();
            d = /(chrome)[ \/]([\w.]+)/.exec(d) || /(webkit)[ \/]([\w.]+)/.exec(d) || /(opera)(?:.*version)?[ \/]([\w.]+)/.exec(d) || /(msie) ([\w.]+)/.exec(d) || 0 > d.indexOf("compatible") && /(mozilla)(?:.*? rv:([\w.]+))?/.exec(d) || [];
            return {
                browser: d[1] || "",
                version: d[2] || "0"
            }
        };
        p = d.uaMatch(p);
        d.browser = {};
        p.browser && (d.browser[p.browser] = !0, d.browser.version = p.version);
        d.browser.webkit && (d.browser.safari = !0)
    }
})(jQuery);
jQuery.easing.jswing = jQuery.easing.swing;
jQuery.extend(jQuery.easing, {
    easeOutCubic: function(d, p, t, u, k) {
        return u * ((p = p / k - 1) * p * p + 1) + t
    },
    easeOutExpo: function(d, p, t, u, k) {
        return p == k ? t + u : u * (-Math.pow(2, -10 * p / k) + 1) + t
    }
});
window.Modernizr = function(d, p, t) {
    function u(a, b) {
        for (var c in a)
            if (s[a[c]] !== t) return "pfx" == b ? a[c] : !0;
        return !1
    }

    function k(a, b, c) {
        var e = a.charAt(0).toUpperCase() + a.substr(1),
            f = (a + " " + B.join(e + " ") + e).split(" ");
        if ("string" === typeof b || "undefined" === typeof b) b = u(f, b);
        else a: {
            f = (a + " " + A.join(e + " ") + e).split(" "), a = f;
            for (var r in a)
                if (e = b[a[r]], e !== t) {
                    b = !1 === c ? a[r] : "function" === typeof e ? e.bind(c || b) : e;
                    break a
                }
            b = !1
        }
        return b
    }
    var m = {},
        w = p.documentElement,
        n = p.createElement("modernizr"),
        s = n.style;
    d = " -webkit- -moz- -o- -ms- ".split(" ");
    var B = ["Webkit", "Moz", "O", "ms"],
        A = ["webkit", "moz", "o", "ms"],
        n = {},
        a = [],
        c = a.slice,
        b, e = function(a, b, c, e) {
            var f, r, d, g = p.createElement("div"),
                v = p.body,
                h = v ? v : p.createElement("body");
            if (parseInt(c, 10))
                for (; c--;) d = p.createElement("div"), d.id = e ? e[c] : "modernizr" + (c + 1), g.appendChild(d);
            return f = ["&#173;<style>", a, "</style>"].join(""), g.id = "modernizr", (v ? g : h).innerHTML += f, h.appendChild(g), v || (h.style.background = "", w.appendChild(h)), r = b(g, a), v ? g.parentNode.removeChild(g) : h.parentNode.removeChild(h), !!r
        },
        f = {}.hasOwnProperty,
        g;
    "undefined" === typeof f || "undefined" === typeof f.call ? g = function(a, b) {
        return b in a && "undefined" === typeof a.constructor.prototype[b]
    } : g = function(a, b) {
        return f.call(a, b)
    };
    Function.prototype.bind || (Function.prototype.bind = function(a) {
        var b = this;
        if ("function" != typeof b) throw new TypeError;
        var e = c.call(arguments, 1),
            f = function() {
                if (this instanceof f) {
                    var d = function() {};
                    d.prototype = b.prototype;
                    var d = new d,
                        r = b.apply(d, e.concat(c.call(arguments)));
                    return Object(r) === r ? r : d
                }
                return b.apply(a, e.concat(c.call(arguments)))
            };
        return f
    });
    (function(a, b) {
        var c = a.join(""),
            f = b.length;
        e(c, function(a, b) {
            for (var c = a.childNodes, e = {}; f--;) e[c[f].id] = c[f];
            m.csstransforms3d = 9 === (e.csstransforms3d && e.csstransforms3d.offsetLeft) && 3 === e.csstransforms3d.offsetHeight
        }, f, b)
    })([, ["@media (", d.join("transform-3d),("), "modernizr){#csstransforms3d{left:9px;position:absolute;height:3px;}}"].join("")], [, "csstransforms3d"]);
    n.csstransforms3d = function() {
        var a = !!k("perspective");
        return a && "webkitPerspective" in w.style && (a = m.csstransforms3d), a
    };
    for (var h in n) g(n, h) && (b = h.toLowerCase(), m[b] = n[h](), a.push((m[b] ? "" : "no-") + b));
    s.cssText = "";
    return n = null, m._version = "2.5.3", m._prefixes = d, m._domPrefixes = A, m._cssomPrefixes = B, m.testProp = function(a) {
        return u([a])
    }, m.testAllProps = k, m.testStyles = e, m.prefixed = function(a, b, c) {
        return b ? k(a, b, c) : k(a, "pfx")
    }, m
}(this, this.document);
(function(d, p, t) {
    function u(d) {
        d = d || location.href;
        return "#" + d.replace(/^[^#]*#?(.*)$/, "$1")
    }
    "$:nomunge";
    var k = document,
        m, w = d.event.special,
        n = k.documentMode,
        s = "onhashchange" in p && (n === t || 7 < n);
    d.fn.hashchange = function(d) {
        return d ? this.bind("hashchange", d) : this.trigger("hashchange")
    };
    d.fn.hashchange.delay = 50;
    w.hashchange = d.extend(w.hashchange, {
        setup: function() {
            if (s) return !1;
            d(m.start)
        },
        teardown: function() {
            if (s) return !1;
            d(m.stop)
        }
    });
    m = function() {
        function m() {
            var b = u(),
                h = f(c);
            b !== c ? (e(c = b, h), d(p).trigger("hashchange")) :
                h !== c && (location.href = location.href.replace(/#.*/, "") + h);
            a = setTimeout(m, d.fn.hashchange.delay)
        }
        var n = {},
            a, c = u(),
            b = function(a) {
                return a
            },
            e = b,
            f = b;
        n.start = function() {
            a || m()
        };
        n.stop = function() {
            a && clearTimeout(a);
            a = t
        };
        d.browser.msie && !s && function() {
            var a, c;
            n.start = function() {
                a || (c = (c = d.fn.hashchange.src) && c + u(), a = d('<iframe tabindex="-1" title="empty"/>').hide().one("load", function() {
                    c || e(u());
                    m()
                }).attr("src", c || "javascript:0").insertAfter("body")[0].contentWindow, k.onpropertychange = function() {
                    try {
                        "title" ===
                        event.propertyName && (a.document.title = k.title)
                    } catch (b) {}
                })
            };
            n.stop = b;
            f = function() {
                return u(a.location.href)
            };
            e = function(b, c) {
                var e = a.document,
                    f = d.fn.hashchange.domain;
                b !== c && (e.title = k.title, e.open(), f && e.write('<script>document.domain="' + f + '"\x3c/script>'), e.close(), a.location.hash = b)
            }
        }();
        return n
    }()
})(jQuery, this);
! function(d, p) {
    function t() {
        k.READY || (q.determineEventTypes(), l.each(k.gestures, function(a) {
            z.register(a)
        }), q.onTouch(k.DOCUMENT, e, z.detect), q.onTouch(k.DOCUMENT, f, z.detect), k.READY = !0)
    }

    function u(a, b) {
        Date.now || (Date.now = function() {
            return (new Date).getTime()
        });
        a.utils.each(["on", "off"], function(c) {
            a.utils[c] = function(a, e, f) {
                b(a)[c](e, function(a) {
                    var c = b.extend({}, a.originalEvent, a);
                    c.button === p && (c.button = a.which - 1);
                    f.call(this, c)
                })
            }
        });
        a.Instance.prototype.trigger = function(a, c) {
            var e = b(this.element);
            return e.has(c.target).length && (e = b(c.target)), e.trigger({
                type: a,
                gesture: c
            })
        };
        b.fn.hammer = function(c) {
            return this.each(function() {
                var e = b(this),
                    f = e.data("hammer");
                f ? f && c && a.utils.extend(f.options, c) : e.data("hammer", new a(this, c || {}))
            })
        }
    }
    var k = function r(a, b) {
        return new r.Instance(a, b || {})
    };
    k.VERSION = "1.1.3";
    k.defaults = {
        behavior: {
            userSelect: "none",
            touchAction: "pan-y",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    k.DOCUMENT = document;
    k.HAS_POINTEREVENTS =
        navigator.pointerEnabled || navigator.msPointerEnabled;
    k.HAS_TOUCHEVENTS = "ontouchstart" in d;
    k.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);
    k.NO_MOUSEEVENTS = k.HAS_TOUCHEVENTS && k.IS_MOBILE || k.HAS_POINTEREVENTS;
    k.CALCULATE_INTERVAL = 25;
    var m = {},
        w = k.DIRECTION_DOWN = "down",
        n = k.DIRECTION_LEFT = "left",
        s = k.DIRECTION_UP = "up",
        B = k.DIRECTION_RIGHT = "right",
        A = k.POINTER_MOUSE = "mouse",
        a = k.POINTER_TOUCH = "touch",
        c = k.POINTER_PEN = "pen",
        b = k.EVENT_START = "start",
        e = k.EVENT_MOVE = "move",
        f = k.EVENT_END =
        "end",
        g = k.EVENT_RELEASE = "release",
        h = k.EVENT_TOUCH = "touch";
    k.READY = !1;
    k.plugins = k.plugins || {};
    k.gestures = k.gestures || {};
    var l = k.utils = {
        extend: function(a, b, c) {
            for (var e in b) !b.hasOwnProperty(e) || a[e] !== p && c || (a[e] = b[e]);
            return a
        },
        on: function(a, b, c) {
            a.addEventListener(b, c, !1)
        },
        off: function(a, b, c) {
            a.removeEventListener(b, c, !1)
        },
        each: function(a, b, c) {
            var e, f;
            if ("forEach" in a) a.forEach(b, c);
            else if (a.length !== p)
                for (e = 0, f = a.length; f > e && !1 !== b.call(c, a[e], e, a); e++);
            else
                for (e in a)
                    if (a.hasOwnProperty(e) &&
                        !1 === b.call(c, a[e], e, a)) break
        },
        inStr: function(a, b) {
            return -1 < a.indexOf(b)
        },
        inArray: function(a, b) {
            if (a.indexOf) {
                var c = a.indexOf(b);
                return -1 === c ? !1 : c
            }
            for (var c = 0, e = a.length; e > c; c++)
                if (a[c] === b) return c;
            return !1
        },
        toArray: function(a) {
            return Array.prototype.slice.call(a, 0)
        },
        hasParent: function(a, b) {
            for (; a;) {
                if (a == b) return !0;
                a = a.parentNode
            }
            return !1
        },
        getCenter: function(a) {
            var b = [],
                c = [],
                e = [],
                f = [],
                d = Math.min,
                g = Math.max;
            return 1 === a.length ? {
                    pageX: a[0].pageX,
                    pageY: a[0].pageY,
                    clientX: a[0].clientX,
                    clientY: a[0].clientY
                } :
                (l.each(a, function(a) {
                    b.push(a.pageX);
                    c.push(a.pageY);
                    e.push(a.clientX);
                    f.push(a.clientY)
                }), {
                    pageX: (d.apply(Math, b) + g.apply(Math, b)) / 2,
                    pageY: (d.apply(Math, c) + g.apply(Math, c)) / 2,
                    clientX: (d.apply(Math, e) + g.apply(Math, e)) / 2,
                    clientY: (d.apply(Math, f) + g.apply(Math, f)) / 2
                })
        },
        getVelocity: function(a, b, c) {
            return {
                x: Math.abs(b / a) || 0,
                y: Math.abs(c / a) || 0
            }
        },
        getAngle: function(a, b) {
            return 180 * Math.atan2(b.clientY - a.clientY, b.clientX - a.clientX) / Math.PI
        },
        getDirection: function(a, b) {
            var c = Math.abs(a.clientX - b.clientX),
                e = Math.abs(a.clientY - b.clientY);
            return c >= e ? 0 < a.clientX - b.clientX ? n : B : 0 < a.clientY - b.clientY ? s : w
        },
        getDistance: function(a, b) {
            var c = b.clientX - a.clientX,
                e = b.clientY - a.clientY;
            return Math.sqrt(c * c + e * e)
        },
        getScale: function(a, b) {
            return 2 <= a.length && 2 <= b.length ? this.getDistance(b[0], b[1]) / this.getDistance(a[0], a[1]) : 1
        },
        getRotation: function(a, b) {
            return 2 <= a.length && 2 <= b.length ? this.getAngle(b[1], b[0]) - this.getAngle(a[1], a[0]) : 0
        },
        isVertical: function(a) {
            return a == s || a == w
        },
        setPrefixedCss: function(a, b, c, e) {
            var f = ["", "Webkit", "Moz", "O", "ms"];
            b = l.toCamelCase(b);
            for (var d = 0; d < f.length; d++) {
                var g = b;
                if (f[d] && (g = f[d] + g.slice(0, 1).toUpperCase() + g.slice(1)), g in a.style) {
                    a.style[g] = (null == e || e) && c || "";
                    break
                }
            }
        },
        toggleBehavior: function(a, b, c) {
            if (b && a && a.style) {
                l.each(b, function(b, e) {
                    l.setPrefixedCss(a, e, b, c)
                });
                var e = c && function() {
                    return !1
                };
                "none" == b.userSelect && (a.onselectstart = e);
                "none" == b.userDrag && (a.ondragstart = e)
            }
        },
        toCamelCase: function(a) {
            return a.replace(/[_-]([a-z])/g, function(a) {
                return a[1].toUpperCase()
            })
        }
    };
    k.Instance = function(a, c) {
        var e = this;
        t();
        this.element = a;
        this.enabled = !0;
        l.each(c, function(a, b) {
            delete c[b];
            c[l.toCamelCase(b)] = a
        });
        this.options = l.extend(l.extend({}, k.defaults), c || {});
        this.options.behavior && l.toggleBehavior(this.element, this.options.behavior, !0);
        this.eventStartHandler = q.onTouch(a, b, function(a) {
            e.enabled && a.eventType == b ? z.startDetect(e, a) : a.eventType == h && z.detect(a)
        });
        this.eventHandlers = []
    };
    k.Instance.prototype = {
        on: function(a, b) {
            var c = this;
            return q.on(c.element, a, b, function(a) {
                c.eventHandlers.push({
                    gesture: a,
                    handler: b
                })
            }), c
        },
        off: function(a, b) {
            var c = this;
            return q.off(c.element, a, b, function(a) {
                a = l.inArray({
                    gesture: a,
                    handler: b
                });
                !1 !== a && c.eventHandlers.splice(a, 1)
            }), c
        },
        trigger: function(a, b) {
            b || (b = {});
            var c = k.DOCUMENT.createEvent("Event");
            c.initEvent(a, !0, !0);
            c.gesture = b;
            var e = this.element;
            return l.hasParent(b.target, e) && (e = b.target), e.dispatchEvent(c), this
        },
        enable: function(a) {
            return this.enabled = a, this
        },
        dispose: function() {
            var a, c;
            l.toggleBehavior(this.element, this.options.behavior, !1);
            for (a = -1; c = this.eventHandlers[++a];) l.off(this.element,
                c.gesture, c.handler);
            return this.eventHandlers = [], q.off(this.element, m[b], this.eventStartHandler), null
        }
    };
    var q = k.event = {
            preventMouseEvents: !1,
            started: !1,
            shouldDetect: !1,
            on: function(a, b, c, e) {
                b = b.split(" ");
                l.each(b, function(b) {
                    l.on(a, b, c);
                    e && e(b)
                })
            },
            off: function(a, b, c, e) {
                b = b.split(" ");
                l.each(b, function(b) {
                    l.off(a, b, c);
                    e && e(b)
                })
            },
            onTouch: function(c, e, d) {
                var g = this,
                    h = function(h) {
                        var q, z = h.type.toLowerCase(),
                            D = k.HAS_POINTEREVENTS;
                        (z = l.inStr(z, "mouse")) && g.preventMouseEvents || (z && e == b && 0 === h.button ? (g.preventMouseEvents = !1, g.shouldDetect = !0) : D && e == b ? g.shouldDetect = 1 === h.buttons || C.matchType(a, h) : z || e != b || (g.preventMouseEvents = !0, g.shouldDetect = !0), D && e != f && C.updatePointer(e, h), g.shouldDetect && (q = g.doDetect.call(g, h, e, c, d)), q == f && (g.preventMouseEvents = !1, g.shouldDetect = !1, C.reset()), D && e == f && C.updatePointer(e, h))
                    };
                return this.on(c, m[e], h), h
            },
            doDetect: function(a, c, d, l) {
                var q = this.getTouchList(a, c),
                    k = c,
                    m = q.trigger,
                    n = q.length;
                c == b ? m = h : c == f && (m = g, n = q.length - (a.changedTouches ? a.changedTouches.length : 1));
                0 < n && this.started &&
                    (k = e);
                this.started = !0;
                a = this.collectEventData(d, k, q, a);
                return c != f && l.call(z, a), m && (a.changedLength = n, a.eventType = m, l.call(z, a), a.eventType = k, delete a.changedLength), k == f && (l.call(z, a), this.started = !1), k
            },
            determineEventTypes: function() {
                var a;
                return a = k.HAS_POINTEREVENTS ? d.PointerEvent ? ["pointerdown", "pointermove", "pointerup pointercancel lostpointercapture"] : ["MSPointerDown", "MSPointerMove", "MSPointerUp MSPointerCancel MSLostPointerCapture"] : k.NO_MOUSEEVENTS ? ["touchstart", "touchmove", "touchend touchcancel"] : ["touchstart mousedown", "touchmove mousemove", "touchend touchcancel mouseup"], m[b] = a[0], m[e] = a[1], m[f] = a[2], m
            },
            getTouchList: function(a, b) {
                if (k.HAS_POINTEREVENTS) return C.getTouchList();
                if (a.touches) {
                    if (b == e) return a.touches;
                    var c = [],
                        f = [].concat(l.toArray(a.touches), l.toArray(a.changedTouches)),
                        d = [];
                    return l.each(f, function(a) {
                        !1 === l.inArray(c, a.identifier) && d.push(a);
                        c.push(a.identifier)
                    }), d
                }
                return a.identifier = 1, [a]
            },
            collectEventData: function(b, e, f, d) {
                b = a;
                return l.inStr(d.type, "mouse") || C.matchType(A,
                    d) ? b = A : C.matchType(c, d) && (b = c), {
                    center: l.getCenter(f),
                    timeStamp: Date.now(),
                    target: d.target,
                    touches: f,
                    eventType: e,
                    pointerType: b,
                    srcEvent: d,
                    preventDefault: function() {
                        var a = this.srcEvent;
                        a.preventManipulation && a.preventManipulation();
                        a.preventDefault && a.preventDefault()
                    },
                    stopPropagation: function() {
                        this.srcEvent.stopPropagation()
                    },
                    stopDetect: function() {
                        return z.stopDetect()
                    }
                }
            }
        },
        C = k.PointerEvent = {
            pointers: {},
            getTouchList: function() {
                var a = [];
                return l.each(this.pointers, function(b) {
                    a.push(b)
                }), a
            },
            updatePointer: function(a,
                b) {
                a == f || a != f && 1 !== b.buttons ? delete this.pointers[b.pointerId] : (b.identifier = b.pointerId, this.pointers[b.pointerId] = b)
            },
            matchType: function(b, e) {
                if (!e.pointerType) return !1;
                var f = e.pointerType,
                    d = {};
                return d[A] = f === (e.MSPOINTER_TYPE_MOUSE || A), d[a] = f === (e.MSPOINTER_TYPE_TOUCH || a), d[c] = f === (e.MSPOINTER_TYPE_PEN || c), d[b]
            },
            reset: function() {
                this.pointers = {}
            }
        },
        z = k.detection = {
            gestures: [],
            current: null,
            previous: null,
            stopped: !1,
            startDetect: function(a, b) {
                this.current || (this.stopped = !1, this.current = {
                    inst: a,
                    startEvent: l.extend({},
                        b),
                    lastEvent: !1,
                    lastCalcEvent: !1,
                    futureCalcEvent: !1,
                    lastCalcData: {},
                    name: ""
                }, this.detect(b))
            },
            detect: function(a) {
                if (this.current && !this.stopped) {
                    a = this.extendEventData(a);
                    var b = this.current.inst,
                        c = b.options;
                    return l.each(this.gestures, function(e) {
                        !this.stopped && b.enabled && c[e.name] && e.handler.call(e, a, b)
                    }, this), this.current && (this.current.lastEvent = a), a.eventType == f && this.stopDetect(), a
                }
            },
            stopDetect: function() {
                this.previous = l.extend({}, this.current);
                this.current = null;
                this.stopped = !0
            },
            getCalculatedData: function(a,
                b, c, e, f) {
                var d = this.current,
                    q = !1,
                    z = d.lastCalcEvent,
                    m = d.lastCalcData;
                z && a.timeStamp - z.timeStamp > k.CALCULATE_INTERVAL && (b = z.center, c = a.timeStamp - z.timeStamp, e = a.center.clientX - z.center.clientX, f = a.center.clientY - z.center.clientY, q = !0);
                a.eventType != h && a.eventType != g || (d.futureCalcEvent = a);
                (!d.lastCalcEvent || q) && (m.velocity = l.getVelocity(c, e, f), m.angle = l.getAngle(b, a.center), m.direction = l.getDirection(b, a.center), d.lastCalcEvent = d.futureCalcEvent || a, d.futureCalcEvent = a);
                a.velocityX = m.velocity.x;
                a.velocityY =
                    m.velocity.y;
                a.interimAngle = m.angle;
                a.interimDirection = m.direction
            },
            extendEventData: function(a) {
                var b = this.current,
                    c = b.startEvent,
                    b = b.lastEvent || c;
                a.eventType != h && a.eventType != g || (c.touches = [], l.each(a.touches, function(a) {
                    c.touches.push({
                        clientX: a.clientX,
                        clientY: a.clientY
                    })
                }));
                var e = a.timeStamp - c.timeStamp,
                    f = a.center.clientX - c.center.clientX,
                    d = a.center.clientY - c.center.clientY;
                return this.getCalculatedData(a, b.center, e, f, d), l.extend(a, {
                    startEvent: c,
                    deltaTime: e,
                    deltaX: f,
                    deltaY: d,
                    distance: l.getDistance(c.center,
                        a.center),
                    angle: l.getAngle(c.center, a.center),
                    direction: l.getDirection(c.center, a.center),
                    scale: l.getScale(c.touches, a.touches),
                    rotation: l.getRotation(c.touches, a.touches)
                }), a
            },
            register: function(a) {
                var b = a.defaults || {};
                return b[a.name] === p && (b[a.name] = !0), l.extend(k.defaults, b, !0), a.index = a.index || 1E3, this.gestures.push(a), this.gestures.sort(function(a, b) {
                    return a.index < b.index ? -1 : a.index > b.index ? 1 : 0
                }), this.gestures
            }
        };
    ! function(a) {
        var c = !1;
        k.gestures.Drag = {
            name: a,
            index: 50,
            handler: function(d, h) {
                var q =
                    z.current;
                if (!(0 < h.options.dragMaxTouches && d.touches.length > h.options.dragMaxTouches)) switch (d.eventType) {
                    case b:
                        c = !1;
                        break;
                    case e:
                        if (d.distance < h.options.dragMinDistance && q.name != a) break;
                        var k = q.startEvent.center;
                        if (q.name != a && (q.name = a, h.options.dragDistanceCorrection && 0 < d.distance)) {
                            var m = Math.abs(h.options.dragMinDistance / d.distance);
                            k.pageX += d.deltaX * m;
                            k.pageY += d.deltaY * m;
                            k.clientX += d.deltaX * m;
                            k.clientY += d.deltaY * m;
                            d = z.extendEventData(d)
                        }(q.lastEvent.dragLockToAxis || h.options.dragLockToAxis &&
                            h.options.dragLockMinDistance <= d.distance) && (d.dragLockToAxis = !0);
                        q = q.lastEvent.direction;
                        d.dragLockToAxis && q !== d.direction && (d.direction = l.isVertical(q) ? 0 > d.deltaY ? s : w : 0 > d.deltaX ? n : B);
                        c || (h.trigger(a + "start", d), c = !0);
                        h.trigger(a, d);
                        h.trigger(a + d.direction, d);
                        q = l.isVertical(d.direction);
                        (h.options.dragBlockVertical && q || h.options.dragBlockHorizontal && !q) && d.preventDefault();
                        break;
                    case g:
                        c && d.changedLength <= h.options.dragMaxTouches && (h.trigger(a + "end", d), c = !1);
                        break;
                    case f:
                        c = !1
                }
            },
            defaults: {
                dragMinDistance: 10,
                dragDistanceCorrection: !0,
                dragMaxTouches: 1,
                dragBlockHorizontal: !1,
                dragBlockVertical: !1,
                dragLockToAxis: !1,
                dragLockMinDistance: 25
            }
        }
    }("drag");
    k.gestures.Gesture = {
        name: "gesture",
        index: 1337,
        handler: function(a, b) {
            b.trigger(this.name, a)
        }
    };
    (function(a) {
        var c;
        k.gestures.Hold = {
            name: a,
            index: 10,
            defaults: {
                holdTimeout: 500,
                holdThreshold: 2
            },
            handler: function(f, d) {
                var h = d.options,
                    l = z.current;
                switch (f.eventType) {
                    case b:
                        clearTimeout(c);
                        l.name = a;
                        c = setTimeout(function() {
                            l && l.name == a && d.trigger(a, f)
                        }, h.holdTimeout);
                        break;
                    case e:
                        f.distance > h.holdThreshold && clearTimeout(c);
                        break;
                    case g:
                        clearTimeout(c)
                }
            }
        }
    })("hold");
    k.gestures.Release = {
        name: "release",
        index: 1 / 0,
        handler: function(a, b) {
            a.eventType == g && b.trigger(this.name, a)
        }
    };
    k.gestures.Swipe = {
        name: "swipe",
        index: 40,
        defaults: {
            swipeMinTouches: 1,
            swipeMaxTouches: 1,
            swipeVelocityX: .6,
            swipeVelocityY: .6
        },
        handler: function(a, b) {
            if (a.eventType == g) {
                var c = a.touches.length,
                    e = b.options;
                c < e.swipeMinTouches || c > e.swipeMaxTouches || (a.velocityX > e.swipeVelocityX || a.velocityY > e.swipeVelocityY) &&
                    (b.trigger(this.name, a), b.trigger(this.name + a.direction, a))
            }
        }
    };
    (function(a) {
        var c = !1;
        k.gestures.Tap = {
            name: a,
            index: 100,
            handler: function(d, g) {
                var h, q, k = g.options,
                    m = z.current,
                    n = z.previous;
                switch (d.eventType) {
                    case b:
                        c = !1;
                        break;
                    case e:
                        c = c || d.distance > k.tapMaxDistance;
                        break;
                    case f:
                        !l.inStr(d.srcEvent.type, "cancel") && d.deltaTime < k.tapMaxTime && !c && (h = n && n.lastEvent && d.timeStamp - n.lastEvent.timeStamp, q = !1, n && n.name == a && h && h < k.doubleTapInterval && d.distance < k.doubleTapDistance && (g.trigger("doubletap", d), q = !0), (!q || k.tapAlways) && (m.name = a, g.trigger(m.name, d)))
                }
            },
            defaults: {
                tapMaxTime: 250,
                tapMaxDistance: 10,
                tapAlways: !0,
                doubleTapDistance: 20,
                doubleTapInterval: 300
            }
        }
    })("tap");
    k.gestures.Touch = {
        name: "touch",
        index: -1 / 0,
        defaults: {
            preventDefault: !1,
            preventMouse: !1
        },
        handler: function(a, b) {
            return b.options.preventMouse && a.pointerType == A ? void a.stopDetect() : (b.options.preventDefault && a.preventDefault(), void(a.eventType == h && b.trigger("touch", a)))
        }
    };
    (function(a) {
        var c = !1;
        k.gestures.Transform = {
            name: a,
            index: 45,
            defaults: {
                transformMinScale: .01,
                transformMinRotation: 1
            },
            handler: function(f, d) {
                switch (f.eventType) {
                    case b:
                        c = !1;
                        break;
                    case e:
                        if (2 > f.touches.length) break;
                        var h = Math.abs(1 - f.scale),
                            l = Math.abs(f.rotation);
                        if (h < d.options.transformMinScale && l < d.options.transformMinRotation) break;
                        z.current.name = a;
                        c || (d.trigger(a + "start", f), c = !0);
                        d.trigger(a, f);
                        l > d.options.transformMinRotation && d.trigger("rotate", f);
                        h > d.options.transformMinScale && (d.trigger("pinch", f), d.trigger("pinch" + (1 > f.scale ? "in" : "out"), f));
                        break;
                    case g:
                        c && 2 > f.changedLength && (d.trigger(a +
                            "end", f), c = !1)
                }
            }
        }
    })("transform");
    d.Hammer = k;
    "undefined" != typeof module && module.exports && (module.exports = k);
    "function" == typeof define && define.amd ? define(["jquery"], function(a) {
        return u(d.Hammer, a)
    }) : u(d.Hammer, d.jQuery || d.Zepto)
}(window);
(function(d) {
    function p(a, c) {
        a = d(a);
        var b = this;
        this.elem = a;
        this.id = a.attr("id");
        this.pages = [];
        this.opts = c;
        this.currentPage = null;
        this.pageWidth = c.width / 2;
        this.pageHeight = c.height;
        this.startPage = c.startPage;
        this.onShowPage = c.onShowPage;
        this.slideShow = c.slideShow;
        this.slideShowDelay = c.slideShowDelay;
        this.pauseOnHover = c.pauseOnHover;
        this.turnPageDuration = c.turnPageDuration;
        this.foldGradient = c.foldGradient;
        this.foldGradientThreshold = c.foldGradientThreshold;
        this.shadows = c.shadows;
        this.shadowThreshold = c.shadowThreshold;
        this.clipBoundaries = c.clipBoundaries;
        this.zoomLevel = 1;
        this.zoomMax = Math.max(c.zoomMax, 1);
        this.zoomMin = c.zoomMin;
        this.zoomBoundingBox = c.zoomBoundingBox;
        this.zoomStep = c.zoomStep;
        this.onZoom = c.onZoom;
        this.mouseWheel = c.mouseWheel;
        this.flipSound = c.flipSound;
        this.centeredWhenClosed = c.centeredWhenClosed;
        this.sectionDefinition = c.sections;
        this.rtl = !!c.rtl;
        this.closable = c.closable;
        d.wowBook.support.filters = "filters" in a[0];
        a.addClass("wowbook");
        "static" === a.css("position") && a.css("position", "relative");
        var e =
            a.children();
        if (e.length < c.pageCount) {
            for (var f = c.pageCount - e.length; f--;) a.append("<div />");
            e = a.children()
        }
        f = this.pagesContainer = this.origin = d("<div class='wowbook-origin'></div>").css({
            position: "absolute"
        }).appendTo(a);
        b.bookShadow = d("<div class='wowbook-book-shadow'></div>").appendTo(a).css({
            top: 0,
            position: "absolute",
            display: "none",
            zIndex: 0
        });
        this.insertPages(e, !0);
        f.append("<div class='wowbook-shadow-clipper'><div class='wowbook-shadow-container'><div class='wowbook-shadow-internal'></div></div></div>");
        b.shadowContainer = d(".wowbook-shadow-container", f);
        b.internalShadow = d(".wowbook-shadow-internal", f);
        b.shadowClipper = d(".wowbook-shadow-clipper", f).css({
            display: "none"
        });
        b.foldShadow = d("<div class='wowbook-shadow-fold'></div>").appendTo(b.shadowContainer);
        b.foldGradientContainer = d("<div class='wowbook-fold-gradient-container'></div>").appendTo(b.shadowContainer);
        b.foldGradientElem = d("<div class='wowbook-fold-gradient'></div>").appendTo(b.foldGradientContainer);
        b.hardPageShadow = d("<div class='wowbook-hard-page-shadow'></div>").css({
            display: "none"
        }).appendTo(f);
        !d.support.opacity && d.wowBook.support.filters && d.wowBook.applyAlphaImageLoader(["wowbook-fold-gradient", "wowbook-fold-gradient-flipped", "wowbook-shadow-fold", "wowbook-shadow-fold-flipped"]);
        b.shadowContainer.css("position", "relative");
        this.leftHandle = d("<div class='wowbook-handle wowbook-left'></div>").data("corner", "l").appendTo(f);
        this.rightHandle = d("<div class='wowbook-handle wowbook-right'></div>").data("corner", "r").appendTo(f);
        Modernizr.csstransforms3d && (e = d("<div>").css("transform", "perspective(1px)"),
            this.perspectiveUnit = "none" != e.css("transform") ? "px" : "", e = null);
        d.browser.msie && d(".wowbook-handle", a).css({
            backgroundColor: "#fff",
            opacity: "0.01"
        });
        d(".wowbook-handle", f).bind("mousedown.wowbook", function(a) {
            return b.pageEdgeDragStart(a)
        });
        c.curl && d(".wowbook-handle", f).hover(function(a) {
            b.curlTimer || (b.curlTimer = setTimeout(function() {
                var c = a.target == b.leftHandle[0] ? b.leftPage() : b.rightPage();
                if (c) {
                    var e = c.offset();
                    b.curl(c, a.pageY - e.top > b.pageHeight / 2)
                }
            }, 120))
        }, function() {
            b.curlTimer = clearTimeout(b.curlTimer);
            b.uncurl()
        });
        var g, h;
        d(".wowbook-handle", f).on("mousedown.wowbook", function() {
            g = d.now();
            h = d(this).data("corner")
        }).on("mouseup.wowbook", function() {
            var a = d(this).data("corner");
            if (!((new Date).getTime() - g > b.opts.handleClickDuration || a != h)) {
                b._cantStopAnimation || b.stopAnimation(!1);
                if ("r" === a) b[b.rtl ? "back" : "advance"]();
                if ("l" === a) b[b.rtl ? "advance" : "back"]();
                h = ""
            }
        });
        var l = !1;
        a.hover(function(a) {
            if (b.pauseOnHover) {
                l = b.slideShowTimer;
                a = d(b.opts.controls.slideShow);
                var c = a.hasClass("wowbook-disabled");
                b.stopSlideShow();
                a.toggleClass("wowbook-disabled", c)
            }
        }, function() {
            b.pauseOnHover && l && b.startSlideShow()
        });
        this.clipBoundaries && (this.origin.wrap("<div class='wowbook-clipper'><div class='wowbook-inner-clipper'></div></div>"), d(".wowbook-inner-clipper", a).css({
            position: "absolute",
            width: "100%",
            overflow: "hidden"
        }), this.clipper = d(".wowbook-clipper", a).css({
            position: "absolute",
            left: 0,
            top: 0,
            width: "100%",
            overflow: "hidden",
            zIndex: 1
        }));
        a.wrapInner("<div class='wowbook-zoomwindow'><div class='wowbook-zoomcontent'></div></div>");
        this.zoomWindow = d(".wowbook-zoomwindow", a);
        this.zoomContent = d(".wowbook-zoomcontent", a);
        d.browser.ie8mode && this.zoomContent.wrapInner("<div class='IE8-zoom-helper'style='position:relative'></div>");
        this.zoomWindow.css({
            position: "absolute",
            top: 0
        });
        this.zoomContent.css({
            position: "absolute",
            left: 0,
            top: 0
        });
        this.zoomSetup();
        this.setDimensions(this.opts.width, this.opts.height);
        c.scaleToFit && (this.scaleToFit(), this.responsive());
        this.fillToc();
        f = c.useTranslate3d;
        Modernizr.csstransforms3d && f && (d.wowBook.useTranslate3d =
            1 == f || "mobile" == f && d.wowBook.utils.isMobile());
        c.useScale3d = c.useScale3d && Modernizr.csstransforms3d;
        if (c.deepLinking && this.getLocationHash()) {
            var q;
            try {
                q = b.selectorToPage("#" + this.getLocationHash())
            } catch (k) {}
            void 0 === q && (q = b.locationHashToPage());
            "number" === typeof q && (b.startPage = q, u(b.elem) || b.elem[0].scrollIntoView())
        }
        this.flipSound && (this.audio = this.createAudioPlayer());
        this.opts.keyboardNavigation && (q = d.wowBook.defaults.keyboardNavigation, this.rtl && this.opts.keyboardNavigation == q && (this.opts.keyboardNavigation = {
            back: q.advance,
            advance: q.back
        }), d(document).on("keydown.wowbook", function(a) {
            d(a.target).filter("input, textarea, select").length || (a.which === b.opts.keyboardNavigation.back && b.back(), a.which === b.opts.keyboardNavigation.advance && b.advance())
        }));
        d(window).on("hashchange.wowbook", function() {
            var a = window.location.hash;
            if (a === b.locationHashSetTo) b.locationHashSetTo = void 0;
            else {
                var c = (a = "" === a && !b.locationEndsInHash()) ? b.startPage : b.locationHashToPage();
                "number" === typeof c && (b.gotoPage(c, !a), a || u(b.elem) ||
                    b.elem[0].scrollIntoView())
            }
        });
        c.forceBasicPage && (this.foldPage = this.holdHardpage = this.foldPageBasic);
        d.wowBook.support.transform || (this.foldPage = this.foldPageBasic, d.wowBook.support.filters || (this.holdHardpage = this.foldPageBasic));
        this.mouseWheel && ("zoom" == b.mouseWheel && a.bind("mousemove.wowbook mouseenter.wowbook", function(a) {
            b._mousemoveEvent = a
        }), a.mousewheel(function(a, c) {
            if (b.mouseWheel) {
                if ("zoom" === b.mouseWheel) {
                    var e = b.elem.offset(),
                        f = b._mousemoveEvent,
                        d = f.pageX - e.left,
                        e = f.pageY - e.top;
                    0 < c &&
                        b.zoomIn({
                            x: d,
                            y: e
                        });
                    0 > c && b.zoomOut({
                        x: d,
                        y: e
                    })
                } else 0 < c && b.advance(), 0 > c && b.back();
                return !1
            }
        }));
        this.opts.touchEnabled && this.touchSupport();
        this.controllify(this.opts.controls);
        this.opts.thumbnails && this.createThumbnails();
        this.setupFullscreen();
        this.showPage(this.startPage, !1);
        1 != this.opts.zoomLevel && this.zoom(this.opts.zoomLevel, {
            duration: 0
        });
        this.callRAFCallback = function() {
            b.rafCallback()
        };
        window.raf(this.callRAFCallback);
        c.slideShow && this.startSlideShow()
    }

    function t(a, c) {
        var b = Math.cos(c),
            e = Math.sin(c);
        return {
            x: b * a.x - e * a.y,
            y: e * a.x + b * a.y
        }
    }

    function u(a) {
        var c = d(window).height(),
            b = a.offset(),
            e = d(window).scrollTop();
        return b.top > e && b.top + a.height() < e + c
    }

    function k(a, c, b) {
        var e, f, g, h;
        e = f = 0;
        if (!d.wowBook.support.boxSizing) {
            var l;
            e = "none" == a.css("borderTopStyle") ? 0 : w[l = a.css("borderTopWidth")] || parseFloat(l);
            f = "none" == a.css("borderRightStyle") ? 0 : w[l = a.css("borderRightWidth")] || parseFloat(l);
            g = "none" == a.css("borderBottomStyle") ? 0 : w[l = a.css("borderBottomWidth")] || parseFloat(l);
            h = "none" == a.css("borderLeftStyle") ?
                0 : w[l = a.css("borderLeftWidth")] || parseFloat(l);
            f = parseFloat(a.css("paddingLeft")) + parseFloat(a.css("paddingRight")) + h + f;
            e = parseFloat(a.css("paddingTop")) + parseFloat(a.css("paddingBottom")) + e + g
        }
        a.css("width", c - f);
        a.css("height", b - e)
    }
    d.wowBook = function(a) {
        return d(a).data("wowBook")
    };
    d.wowBook.version = "1.0.9";
    d.wowBook.support = {};
    d.fn.wowBook = function(a) {
        if ("string" === typeof a) {
            var c = Array.prototype.slice.call(arguments, 1);
            if ("options" === a || "prop" === a) {
                var b = d.wowBook(this[0]),
                    e = c[0];
                return 1 < c.length ?
                    b[e] = c[1] : b[e]
            }
            return this.each(function() {
                var b = d.wowBook(this);
                b[a].apply(b, c)
            })
        }
        var f = d.extend({}, d.wowBook.defaults, a);
        return this.each(function() {
            var a = new p(this, f);
            d(this).data("wowBook", a)
        })
    };
    p.prototype = {
        destroy: function() {
            this.callRAFCallback = d.noop;
            this.curlTimer = clearTimeout(this.curlTimer);
            d("*").add(document).add(window).off(".wowbook");
            this.destroyThumbnails();
            this.stopSlideShow();
            this.stopAnimation(!1);
            this.elem.empty().removeData().off()
        },
        setDimensions: function(a, c) {
            this.zoomed &&
                this.zoomReset(0);
            this.currentScale = 1;
            var b = this.elem,
                e = this.pageWidth;
            b.css({
                height: c,
                width: a
            });
            var f = b.height();
            this.pageWidth = b.width() / 2;
            this.pageHeight = f;
            this._originalHeight || (this._originalHeight = this.pageHeight);
            this._originalWidth || (this._originalWidth = 2 * this.pageWidth);
            var g = this.origin.css({
                width: "100%",
                height: f
            });
            if (e && this.centeredWhenClosed) {
                var h = parseFloat(g.css("left"), 10);
                g.css("left", h / (e / this.pageWidth))
            }
            this.bookShadow.css({
                width: a,
                height: c
            });
            for (var h = 0, l = this.pages.length; h <
                l; h++) this.pages[h].css({
                width: this.pageWidth,
                height: this.pageHeight,
                left: this.pages[h].onLeft ? 0 : this.pageWidth
            }), e = d(".wowbook-page-content", this.pages[h]), k(e, this.pageWidth, this.pageHeight);
            this.opts.gutterShadow && d(".wowbook-gutter-shadow", b).css("height", this.pageHeight);
            this.positionBookShadow();
            this.shadowClipper.css({
                width: b.width(),
                height: f
            });
            this.hardPageShadow.css({
                width: this.pageWidth,
                height: this.pageHeight
            });
            this.opts.handleWidth && d(".wowbook-handle", g).css("width", this.opts.handleWidth);
            this.rightHandle.css("left", a - this.rightHandle.width());
            this.clipBoundaries && (g = Math.ceil(Math.sqrt(this.pageWidth * this.pageWidth + this.pageHeight * this.pageHeight)), g = [this.pageHeight - g, b.width(), g, 0], this.origin.css("top", -g[0]), d(".wowbook-inner-clipper", b).css({
                width: "100%",
                height: g[2] - g[0],
                top: g[0]
            }), this.clipper.css({
                width: "100%",
                height: f
            }));
            this.zoomWindow.css({
                width: 2 * this.pageWidth,
                height: f
            });
            this.zoomContent.css({
                width: 2 * this.pageWidth,
                height: f
            });
            this.corners = {
                tl: [0, 0],
                bl: [0, this.pageHeight],
                tr: [this.pageWidth, 0],
                br: [this.pageWidth, this.pageHeight],
                l: [0, 0],
                r: [this.pageWidth, 0]
            };
            this.thumbnails && this.updateThumbnails()
        },
        scale: function(a) {
            if (d.wowBook.support.transform) {
                this.zoomed && this.zoom(1, 0, {
                    offset: {
                        dx: 0,
                        dy: 0
                    }
                });
                this.currentScale = a;
                var c = this.zoomContent;
                this.opts.zoomUsingTransform ? c.css({
                    transform: "scale(" + a + ")",
                    transformOrigin: "0 0"
                }) : (c.css("zoom", a), this._cssZoom = a * this.zoomLevel);
                this.elem.css({
                    height: this._originalHeight * a,
                    width: this._originalWidth * a
                });
                this.zoomWindow.css({
                    height: this._originalHeight *
                        a,
                    width: this._originalWidth * a
                });
                if (this.opts.onResize) this.opts.onResize(this)
            }
        },
        scaleToFit: function(a, c) {
            var b = a;
            if (!d.isNumeric(a)) {
                var e = d(a || this.opts.scaleToFit);
                if (!e.length) throw "jQuery selector passed to wowbook.resize did not matched in any DOM element.";
                b = e.width();
                c = e.height()
            }
            e = this._originalWidth / this._originalHeight;
            c * e <= b || (c = b / e);
            this.scale(c / this._originalHeight)
        },
        resize: function(a, c) {
            this.setDimensions(a, c);
            if (this.opts.onResize) this.opts.onResize(this)
        },
        responsive: function() {
            var a =
                this;
            d(window).on("resize.wowbook", function() {
                a.scaleToFit()
            })
        },
        insertPages: function(a, c) {
            for (var b = 0, e = a.length; b < e; b++) this.insertPage(a[b], !0);
            this.updateBook(c)
        },
        insertPage: function(a, c) {
            if (this.isDoublePage(a)) this.insertDoublePage(a, c);
            else {
                a = d(a).addClass("wowbook-page-content");
                var b = d("<div class='wowbook-page'></div>").css({
                    width: this.pageWidth,
                    height: this.pageHeight,
                    display: "none",
                    position: "absolute"
                }).appendTo(this.pagesContainer).append(a);
                d.wowBook.support.boxSizing && a.css(d.wowBook.support.boxSizing,
                    "border-box");
                k(a, this.pageWidth, this.pageHeight);
                b.hardPageSetByUser = a.hasClass("wowbook-hardpage");
                this.opts.gutterShadow && d("<div class='wowbook-gutter-shadow'></div>").appendTo(a).css("height", this.pageHeight);
                this.pages.push(b);
                c || this.updateBook();
                return b
            }
        },
        insertDoublePage: function(a, c) {
            if (!this._insertingDoublePage) {
                this._insertingDoublePage = !0;
                var b = d(a),
                    e = b.clone().insertAfter(b),
                    f = b.add(e);
                b.css("left", 0);
                e.css("right", "100%");
                f.css({
                    width: "200%",
                    height: "100%",
                    position: "relative"
                });
                f.css(d.wowBook.support.boxSizing +
                    "", "border-box").wrap("<div class='wowbook-double-page'></div>");
                b.parent().data("src", b.data("src"));
                e.parent().data("src", e.data("src"));
                b.parent().data("image", b.data("image"));
                e.parent().data("image", e.data("image"));
                var f = this.insertPage(b.parent(), !0),
                    g = this.insertPage(e.parent(), !0);
                f && (f.otherHalf = g);
                g && (g.otherHalf = f);
                d.wowBook.support.boxSizing || (k(b, 2 * this.pageWidth, this.pageHeight), k(e, 2 * this.pageWidth, this.pageHeight));
                c || this.updateBook();
                this._insertingDoublePage = !1
            }
        },
        isDoublePage: function(a) {
            a =
                d(a);
            return a.data("double") || a.is(this.opts.doublePages)
        },
        replaceNumberHolder: function(a, c) {
            if (void 0 == a) return a;
            c += "";
            return a.replace(/\{\{([^}]+)\}\}/g, function(a, e) {
                if (c.length < e.length) {
                    var f = e.replace(/./g, "0");
                    return (f + c).slice(-f.length)
                }
                return c
            })
        },
        loadPage: function(a) {
            "number" === typeof a && (a = this.pages[a]);
            if (a && !a.loaded && !a.loading && (a.src || a.image || a.cached)) {
                if (a.cached) return this.finishPageLoading(a, a.cache);
                a.loading = !0;
                var c = this;
                if (a.src) a.otherHalf && a.otherHalf.loading || d.get(a.src,
                    function(b) {
                        c.finishPageLoading(a, b);
                        a.otherHalf && c.finishPageLoading(a.otherHalf, b)
                    });
                else if (a.image) {
                    var b = new Image;
                    b.onload = function() {
                        c.finishPageLoading(a, this)
                    };
                    d(b).addClass("wowbook-lazy");
                    b.src = a.image
                }
            }
        },
        finishPageLoading: function(a, c) {
            a.loading = !1;
            a.loaded = !0;
            var b = !a.cached;
            a.cached = !1;
            a.removeClass("wowbook-loading");
            var e = a.find(".wowbook-page-content");
            b && (a.image || a.src) && this.isDoublePage(e.children().first()) && (e = e.children().first());
            e.append(c);
            this.upsertNumberInPage(a);
            if (this.opts.onLoadPage) this.opts.onLoadPage(this,
                a, a.pageIndex);
            this.updateThumbnail(a.pageIndex)
        },
        unloadPage: function(a) {
            "number" === typeof a && (a = this.pages[a]);
            if (a && a.loaded && !this.isPageToKeep(a) && (a.cache = a.find(".wowbook-page-content").html(), a.find(".wowbook-page-content").empty(), a.cached = !0, a.loaded = !1, this.opts.onUnloadPage)) this.opts.onUnloadPage(this, a, a.pageIndex)
        },
        isPageToKeep: function(a) {
            if (!this.opts.pagesToKeep) return !1;
            var c = a.find(".wowbook-page-content");
            return a.keep || c.data("keep") || c.is(this.opts.pagesToKeep)
        },
        selectPagesToUnload: function(a) {
            void 0 ==
                a && (a = this.currentPage);
            var c = [],
                b = this.leftPageIndex(a);
            a = this.rightPageIndex(a);
            for (var e = this.pageBelow(b), f = this.pageBelow(a), d = this.backPage(b), h = this.backPage(a), d = d && d.pageIndex, h = h && h.pageIndex, l = 0, q = this.pages.length; l < q; l++) {
                var k = this.pages[l];
                k.loaded && l != b && l != a && l != e && l != f && l != d && l != h && !this.isPageToKeep(k) && c.push(l)
            }
            return c
        },
        loadedPages: function() {
            for (var a = [], c = 0, b = this.pages.length; c < b; c++) this.pages[c].loaded && a.push(c);
            return a
        },
        unloadUnusedPages: function(a) {
            var c = this.loadedPages();
            if (!(c.length <= this.opts.pagesInMemory)) {
                c = c.length - this.opts.pagesInMemory;
                a = this.selectPagesToUnload(a);
                for (var b = 0; b < c; b++) this.unloadPage(a[b])
            }
        },
        removePages: function(a, c) {
            arguments.length || (a = 0, c = -1);
            this.holdedPage && this.releasePage(this.holdedPage);
            var b = this.pages;
            c = (c || a) + 1 || b.length;
            var e = b.slice(a, c),
                d = b.slice(c);
            b.length = 0 > a ? b.length + a : a;
            b.push.apply(b, d);
            for (var d = 0, g = e.length; d < g; d++) e[d].remove();
            this.updateBook();
            return b.length
        },
        updateBook: function(a) {
            this.doPageNumbering();
            this.findPagesType();
            this.positionBookShadow();
            for (var c = this.rtl && this.closable || !this.rtl && !this.closable, b, e = 0, f = this.pages.length; e < f; e++) {
                b = this.pages[e].toggleClass("wowbook-left", c).toggleClass("wowbook-right", !c).data({
                    pageIndex: e,
                    holded: !1
                });
                b.pageIndex = e;
                var g = d(".wowbook-page-content", b);
                b.src = this.replaceNumberHolder(g.data("src") || this.opts.srcs, e);
                b.image = this.replaceNumberHolder(g.data("image") || this.opts.images, e);
                1 != b.loaded && (b.loaded = !b.src && !b.image && !b.cached);
                b.loaded || b.addClass("wowbook-loading");
                b.onLeft = c;
                b.onRight = !c;
                c = !c
            }
            this.findSections();
            a || this.showPage(this.currentPage)
        },
        doPageNumbering: function() {
            var a = this.opts;
            if (a.pageNumbers && this.pages.length) {
                var c = a.numberedPages,
                    a = this.pages.length - 1,
                    b = this.pageIsOnTheLeft(a);
                "all" == c && (c = [0, -1]);
                c || (c = this.closable ? [2, b ? -3 : -2] : [0, -1]);
                var e = c[0],
                    c = c[1];
                0 > e && (e = a + e + 1);
                0 > e && (e = 0);
                e > this.pages.length - 1 && (e = a);
                0 > c && (c = a + c + 1);
                0 > c && (c = 0);
                c > this.pages.length - 1 && (c = a);
                for (var f = this.opts.firstPageNumber, b = 0; b < a; b++) delete this.pages[b].number;
                for (b =
                    0; b < e; b++) d(".wowbook-page-number", this.pages[b]).remove();
                for (b = c + 1; b < a; b++) d(".wowbook-page-number", this.pages[b]).remove();
                for (b = e; b <= c; b++) this.pages[b].number = f, a = d(".wowbook-page-number", this.pages[b]), a.length || (a = d(".wowbook-page-content", this.pages[b]), a = d('<div class="wowbook-page-number"></div>').appendTo(a)), a.html(f++)
            }
        },
        upsertNumberInPage: function(a) {
            "number" === typeof a && (a = this.pages[a]);
            if (a.number || 0 === a.number) {
                var c = d(".wowbook-page-number", a);
                c.length || (content = d(".wowbook-page-content",
                    a), c = d('<div class="wowbook-page-number"></div>').appendTo(content));
                c.html(a.number)
            }
        },
        findPagesType: function() {
            var a = this.opts,
                c = {},
                b, e, d;
            d = a.hardPages || [];
            var g = !0 === d;
            if (!g)
                for (a.hardcovers && (d.push(0, -1), this.closable && d.push(1), this.otherPage(this.pages.length - 1) || d.push(-2)), a = 0, e = d.length; a < e; a++) b = d[a], 0 > b && (b = this.pages.length + b), 0 <= b && b < this.pages.length && (c[b] = !0);
            for (a = this.pages.length; a--;) d = g || c[a] || this.pages[a].hardPageSetByUser, this.pages[a].toggleClass("wowbook-hardpage", d).isHardPage =
                d
        },
        showPage: function(a, c) {
            0 > a && (a = 0);
            a > this.pages.length - 1 && (a = this.pages.length - 1);
            var b = this.leftPageIndex(a),
                e = this.rightPageIndex(a),
                f = this.pageBelow(b),
                g = this.pageBelow(e),
                h = this.pageWidth,
                l = this.pages.length - 1,
                q, k;
            this.loadPage(b);
            this.loadPage(e);
            this.loadPage(f);
            this.loadPage(g);
            this.loadPage(this.backPage(b));
            this.loadPage(this.backPage(e));
            this.opts.pagesInMemory && this.unloadUnusedPages(a);
            for (var m = 0; m <= l; m++) q = this.pages[m].onLeft != this.rtl ? m : l - m, k = m === f || m === b || m === e || m === g ? "block" : "none",
                this.pages[m].data("zIndex", q).css({
                    display: k,
                    left: this.pages[m].onLeft ? 0 : h,
                    top: 0,
                    zIndex: q
                });
            f = 0 == a || !this.closable && 1 == a;
            l = a == l || a == this.otherPage(l);
            this.leftHandle.toggleClass("wowbook-disabled", !this.backPage(b));
            this.rightHandle.toggleClass("wowbook-disabled", !this.backPage(e));
            this.toggleControl("back", f);
            this.toggleControl("next", l);
            this.toggleControl("first", f);
            this.toggleControl("last", l);
            (b = this.onShowPage) && d.isFunction(b) && !this.isOnPage(a) && (this.currentPage = a, b(this, this.pages[a], a), (e = this.otherPage(a)) && b(this, this.pages[e], e));
            this.currentPage = a;
            this.centeredWhenClosed && (b = !!this.leftPage(a), e = this.rightPage(a), this.origin.css("left", b && e ? 0 : b ? h / 2 : -h / 2));
            this.positionBookShadow();
            !1 !== c && this.opts.updateBrowserURL && this.locationHashToPage() != a && (this.locationHashSetTo = window.location.hash = this.pageToLocationHash(a));
            this.showThumbnail()
        },
        holdPage: function(a, c, b, e, d) {
            "number" === typeof a && (a = this.pages[a]);
            if (a) {
                var g = a.pageIndex,
                    h = this.pages.length - 1,
                    l = !this.otherPage(h);
                if (!e) e =
                    this.pageIsOnTheLeft(g) ? "l" : "r";
                else if (!this.corners[e] || (this.pageIsOnTheLeft(g) ? /r/ : /l/).test(e)) return;
                void 0 === d && (d = this.backPage(g));
                if (d) {
                    var q = d.pageIndex;
                    a.data("holded_info", [c, b, e]);
                    if (this.centeredWhenClosed && (0 === g || 0 === q || l && (q === h || g === h))) {
                        var k = 0,
                            m, n = !this.rtl,
                            r = this.pageWidth,
                            p, w, v, t, s, u, B, A;
                        if (n ? 0 === g : g === h && l) p = -r / 2, w = -r / 4, v = 0, t = -r / 2, s = -r, u = w, B = s, A = c;
                        if (n ? g === h && l : 0 === g) p = r, w = 3 * r / 2, v = r / 2, t = 0, s = r, u = 2 * r, B = c, A = u;
                        if (n ? 0 === q : q === h && l) p = r / 2, w = g === (n ? h : 0) ? r : 3 * r / 2, v = g === (n ? h : 0) ? r / 2 : 0,
                            t = -r / 2, s = p, u = 2 * r, B = c, A = u;
                        if (n ? q === h && l : 0 === q) p = g === (n ? 0 : h) ? 0 : -r / 2, w = r / 2, v = r / 2, t = g === (n ? 0 : h) ? -r / 2 : 0, s = -r, u = w, B = s, A = c;
                        c < p && (k = v, m = B);
                        c > w && (k = t, m = A);
                        c >= p && c <= w && (c = (c - p) / (w - p), k = v + c * (t - v), m = s + c * (u - s));
                        c = m;
                        this.origin.css("left", k);
                        this.positionBookShadow()
                    }
                    this.zoomed || "basic" == this.pageType(a) || "basic" == this.pageType(d) ? this.foldPageBasic(a, c, b, e, d) : a.isHardPage || d.isHardPage ? this.holdHardpage(a, c, b, e, d) : this.foldPage(a, c, b, e, d);
                    if (!a.data("holded") && (a.addClass("wowbook-page-holded"), d.addClass("wowbook-page-holded"),
                            a.data("holded", !0), this.holdedPage = a, this.holdedPageBack = d, this.shadows && this.shadowClipper.css("display", "block"), this.clipBoundaries && this.clipper.css("overflow", "visible"), this.positionBookShadow(), this.opts.onHoldPage)) this.opts.onHoldPage(this, g, a, d)
                }
            }
        },
        foldPage: function(a, c, b, e, d) {
            this._currentFlip || (this._currentFlip = this.foldPageStart(a, c, b, e, d));
            this._currentFlip.page == a && (this._currentFlip.x = c, this._currentFlip.y = b, this._currentFlip.page.data("holdedAt", {
                    x: c,
                    y: b
                }), this._currentFlip.corner =
                e, this.foldPageStyles(this._currentFlip))
        },
        foldPageStart: function(a, c, b, e, d) {
            var g = {};
            "number" === typeof a && (a = this.pages[a]);
            g.book = this;
            g.page = a;
            g.pageIndex = a.data("pageIndex");
            void 0 === d && (d = this.backPage(g.pageIndex));
            if (d && d.length) {
                g.back = d;
                g.pageContent = a.children().first();
                g.backContent = d.children().first();
                var h = this.pageWidth,
                    l = this.pageHeight;
                e || (e = "tl");
                if ("l" == e || "r" == e) {
                    var q = {
                        x: "l" == e ? 0 : h,
                        y: b
                    };
                    a.data("grabPoint", q);
                    g.grabPoint = q;
                    e = (b >= q.y ? "t" : "b") + e
                }
                g.page.data("holdedAt", {
                    x: c,
                    y: b
                });
                g.x = c;
                g.y = b;
                g.page.data("holdedCorner", e);
                g.corner = e;
                g.pageDiagonal = Math.sqrt(h * h + l * l);
                g.page.css("clip", "rect(-1000px 2000px 2000px 0px)");
                g.pageLeft = parseFloat(a.css("left"));
                d.css({
                    left: g.pageLeft + "px",
                    zIndex: 1E5,
                    clip: "rect(-1000px 2000px 2000px 0px)"
                });
                g.shadowHeight = 2 * Math.ceil(g.pageDiagonal);
                g.shadowTop = -(g.shadowHeight - l) / 2;
                this.internalShadow.css({
                    display: "block",
                    height: g.shadowHeight
                });
                g.foldShadowWidth = this.foldShadow.width();
                this.foldShadow.css({
                    display: "block",
                    height: g.shadowHeight
                });
                this.foldGradientContainer.appendTo(g.backContent);
                g.foldGradientWidth = this.foldGradientElem.width();
                g.foldGradientHeight = 2 * Math.ceil(g.pageDiagonal);
                this.foldGradientElem.css("height", g.foldGradientHeight);
                this.foldGradientContainer.css({
                    position: "absolute",
                    width: g.foldGradientWidth,
                    height: g.foldGradientHeight,
                    top: 0,
                    left: 0,
                    display: "none"
                });
                g.foldGradientVisible = !1;
                return g
            }
        },
        foldPageStyles: function(a) {
            var c = this.pageWidth,
                b = this.pageHeight,
                e = c / 2,
                f = b / 2,
                g = d.wowBook.utils.translate,
                h = a.pageLeft,
                l = a.x,
                q = a.y,
                k = a.back,
                m = a.corner || "tl";
            if ("l" == m || "r" == m) {
                var n = a.page.data("grabPoint");
                n || (n = {
                    x: "l" == m ? 0 : c,
                    y: q
                }, page.data("grabPoint", n));
                m = (q >= n.y ? "t" : "b") + (this.pageIsOnTheLeft(a.pageIndex) ? "l" : "r");
                a.corner = m;
                a.page.data("holdedCorner", m);
                var r = l - n.x,
                    p = q - n.y,
                    r = Math.atan2(p, r),
                    n = {
                        x: 0,
                        y: (q >= n.y ? 0 : b) - n.y
                    },
                    n = t(n, 2 * r),
                    l = n.x + l,
                    q = n.y + q
            }
            a.page.data("holdedAt", {
                x: l,
                y: q
            });
            a.page.data("holdedCorner", m);
            var n = this.corners[m],
                m = c - n[0],
                w = n[1],
                r = l - m,
                p = q - w,
                v = Math.sqrt(r * r + p * p);
            v > c && (l = m + c * r / v, q = w + c * p / v);
            var w = b - w,
                r = l - m,
                p = q - w,
                v = Math.sqrt(r * r + p * p),
                s = a.pageDiagonal;
            v > s && (l = m + s * r / v, q = w + s * p / v);
            m = n[0];
            n = n[1];
            n == q && (q = n + .001);
            r = l - m;
            p = q - n;
            v = Math.sqrt(r * r + p * p);
            l = v / 2;
            r = Math.atan2(p, r);
            p = Math.tan(r);
            q = r;
            r = 180 * r / Math.PI;
            w = {
                x: m - e,
                y: f - n
            };
            s = t(w, q);
            v = s.x + l + e + .5;
            a.pageContent.css("transform", g(-v, 0) + " rotate(" + (-r).toFixed(7) + "deg)");
            a.page.css("transform", g((Math.cos(q) * v).toFixed(5), (Math.sin(q) * v).toFixed(5)) + " rotate(" + r.toFixed(7) + "deg)");
            s = this.calculateOpacity(l, c, this.shadowThreshold, 50);
            if (this.shadows && 0 < s) {
                var u =
                    a.shadowTop;
                this.internalShadow.css({
                    transform: g(v + h, u) + " rotate(" + r + "deg)",
                    transformOrigin: e - v + "px " + (f + (a.shadowHeight - b) / 2) + "px"
                });
                v -= a.foldShadowWidth;
                this.foldShadow.css({
                    transform: g(v + h, u) + " rotate(" + r + "deg)",
                    transformOrigin: e - v + "px " + (f + (a.shadowHeight - b) / 2) + "px"
                });
                this.shadowContainer.css({
                    opacity: s,
                    display: "block"
                })
            } else this.shadowContainer.css("display", "none");
            k.show();
            w.x = -w.x;
            s = t(w, -q);
            v = s.x - l + e - 1;
            b = {
                x: s.x - l,
                y: s.y + l * p
            };
            h = {
                x: s.x - l,
                y: s.y - l / (0 == p ? 1E-4 : p)
            };
            b = t(b, -q);
            h = t(h, -q);
            h = -(h.x + e);
            b = -(b.y - f);
            a.backContent.css("transform", g(-v, 0) + " rotate(" + r + "deg)");
            a.back.css("transform", g((m + h + Math.cos(q) * v).toFixed(5), (n - b + Math.sin(q) * v).toFixed(5)) + " rotate(" + r + "deg)");
            s = this.calculateOpacity(2 * l, 2 * c, this.foldGradientThreshold, 50);
            this.foldGradient && 0 < s ? (this.foldGradientContainer.css({
                    opacity: s,
                    display: "block",
                    transform: g(c - m - a.foldGradientWidth / 2, n - a.foldGradientHeight / 2) + " rotate(" + -r + "deg)"
                }), this.foldGradientElem.css("transform", g(-l + a.foldGradientWidth / 2, 0)), a.foldGradientVisible ||
                (this.foldGradientContainer.css("display", "block"), a.foldGradientVisible = !0)) : a.foldGradientVisible && (this.foldGradientContainer.css("display", "none"), a.foldGradientVisible = !1)
        },
        holdHardpage: function(a, c, b, e, d) {
            this._currentFlip || (this._currentFlip = this.flipHardPageStart(a, c, b, e, d));
            this._currentFlip.page == a && (this._currentFlip.x = c, this._currentFlip.y = b, this._currentFlip.page.data("holdedAt", {
                x: c,
                y: b
            }), this._currentFlip.corner = e, this.flipHardPageStyles(this._currentFlip))
        },
        flipHardPageStart: function(a,
            c, b, e, d) {
            this.clipBoundaries && this.clipper.children(".wowbook-inner-clipper").css("overflow", "visible");
            var g = {};
            "number" === typeof a && (a = this.pages[a]);
            g.book = this;
            g.page = a;
            g.pageIndex = a.data("pageIndex");
            void 0 === d && (d = this.backPage(g.pageIndex));
            if (d && d.length) {
                g.back = d;
                var h = this.pageWidth;
                e || (e = "tl");
                a.data("holdedAt", {
                    x: c,
                    y: b
                });
                a.data("holdedCorner", e);
                a.css("zIndex", 1E5);
                d.css("zIndex", 1E5);
                this.opts.use3d && Modernizr.csstransforms3d && (a.css(Modernizr.prefixed("perspectiveOrigin"), "0 50%"), d.css(Modernizr.prefixed("perspectiveOrigin"),
                    "0 50%"));
                c = this.pageIsOnTheLeft(g.pageIndex) ? h : 0;
                a.css("transformOrigin", c + "px 50%");
                d.css("transformOrigin", h - c + "px 50%");
                this.shadows && this.hardPageShadow.css("display", "block");
                return g
            }
        },
        flipHardPageStyles: function(a) {
            var c = a.page,
                b = a.back;
            x = a.x;
            y = a.y;
            var e = this.pageIsOnTheRight(a.pageIndex),
                f = this.pageWidth,
                g = this.pageHeight;
            (a = a.corner) || (a = "tl");
            c.data("holdedAt", {
                x: x,
                y: y
            });
            c.data("holdedCorner", a);
            a = e ? f - x : x;
            var h = e ? 0 : f,
                l;
            0 > a && (a = 0);
            a = (l = a < f) ? c : b;
            (l ? b : c).css("display", "none");
            c = e != l;
            b = x - h;
            b > f && (b = f);
            b < -f && (b = -f);
            h = -Math.sqrt(1600 * (1 - b * b / ((f + 15) * (f + 15))));
            e = Math.abs(b / f);
            h = 1 == e ? 0 : Math.atan2(h, b);
            if (this.opts.use3d && Modernizr.csstransforms3d) {
                var k;
                k = c ? -this._calculateAngleFromX(-b, f) : this._calculateAngleFromX(b, f);
                this.animating && (l = this._animationData, this.curledPage || l.curled ? (l.curled = !0, l.angle || (h = {
                        from: k,
                        to: 0
                    }, l.angle = h, k = b + l.dx, h.to = c ? -this._calculateAngleFromX(-k, f) : this._calculateAngleFromX(k, f), Math.abs(b) == f && (h.from = 0), Math.abs(k) == f && (h.to = 0), h.delta = h.to - h.from), k = l.angle.from -
                    l.angle.delta * (l.from.x - x) / l.dx) : (Math.abs(x - l.from.x), Math.abs(l.dx / 2)));
                a.css({
                    transform: "perspective(" + this.opts.perspective + this.perspectiveUnit + ") rotate3d(0, 1, 0, " + k + "deg)",
                    display: "block"
                })
            } else a.css({
                transform: "skewY(" + h + "rad) scaleX(" + e + ")",
                display: "block"
            });
            !d.wowBook.support.transform && d.wowBook.support.filters && (e = "M11=" + e + ", M12=0, M21=" + Math.tan(h) * e + ", M22=1", a.css("filter", "progid:DXImageTransform.Microsoft.Matrix(" + e + ", sizingMethod='auto expand')"), a.css({
                marginTop: g - a.height(),
                marginLeft: c ? f - a.width() : 0
            }));
            this.shadows && this.hardPageShadow.css({
                left: c ? 0 : f,
                opacity: .5 * Math.abs(b / f)
            })
        },
        _calculateAngleFromX: function(a, c, b) {
            var e = 2 * c / 3;
            if (a > e) {
                var d = this._calculateAngleFromX(e, c, b);
                return d + (a - e) / (c - e) * (0 - d)
            }
            b = b || this.opts.perspective;
            e = 180 / Math.PI;
            d = c * c;
            b *= b;
            var g = a * a;
            a = Math.acos((c * b * a - Math.sqrt(d * d * b * g + d * d * g * g - d * b * g * g)) / (d * b + d * g));
            return a = -a * e
        },
        foldPageBasic: function(a, c, b, e, d) {
            this._currentFlip || (this._currentFlip = this.foldPageBasicStart(a, c, b, e, d));
            this._currentFlip &&
                this._currentFlip.page == a && (this._currentFlip.x = c, this._currentFlip.y = b, this._currentFlip.page.data("holdedAt", {
                    x: c,
                    y: b
                }), this._currentFlip.corner = e, this.foldPageBasicStyles(this._currentFlip))
        },
        foldPageBasicStart: function(a, c, b, e, d) {
            var g = {};
            "number" === typeof a && (a = this.pages[a]);
            g.book = this;
            g.page = a;
            g.pageIndex = a.data("pageIndex");
            void 0 === d && (d = this.backPage(g.pageIndex));
            if (d && d.length) {
                g.back = d;
                var h = this.pageHeight;
                e || (e = "tl");
                a.data("holdedAt", {
                    x: c,
                    y: b
                });
                a.data("holdedCorner", e);
                d.css("zIndex",
                    1E5);
                a.data("foldPageBasic", !0);
                g.foldGradientWidth = this.foldGradientElem.width();
                g.foldShadowWidth = this.foldShadow.width();
                this.internalShadow.css("display", "none");
                this.foldShadow.css({
                    display: "none",
                    height: h,
                    transform: "",
                    top: 0
                }).toggleClass("wowbook-shadow-fold-flipped", a.onRight);
                this.shadowContainer.css("display", "block");
                c = d.children().first();
                this.foldGradientContainer.appendTo(c).css({
                    width: g.foldGradientWidth,
                    height: h,
                    top: 0,
                    transform: "",
                    zIndex: 1E9
                });
                this.foldGradientElem.css({
                    left: 0,
                    height: h
                }).toggleClass("wowbook-fold-gradient-flipped",
                    a.onRight);
                return g
            }
        },
        foldPageBasicStyles: function(a) {
            var c = a.page,
                b = a.back;
            x = a.x;
            y = a.y;
            var e = this.pageWidth,
                d = a.corner;
            d || (d = "tl");
            c.data("holdedAt", {
                x: x,
                y: y
            });
            c.data("holdedCorner", d);
            var g = (d = this.pageIsOnTheLeft(a.pageIndex)) ? x : e - x;
            0 > g && (g = 0);
            g > 2 * e && (g = 2 * e);
            var h = g / 2,
                l, k;
            d ? (l = "rect(-1000px 1000px 1000px " + h + "px)", k = "rect(-1000px 1000px 1000px " + (e - h) + "px)", g -= e) : (l = "rect(-1000px " + (e - h) + "px 1000px -1000px)", k = "rect(-1000px " + h + "px 1000px -1000px)", g = e - g + e);
            c.css("clip", l);
            b.css({
                clip: k,
                left: g,
                display: "block"
            });
            c = this.calculateOpacity(2 * h, 2 * e, this.shadowThreshold, 50);
            this.shadows && 0 < c ? (b = d ? h - a.foldShadowWidth : e - h + e, this.shadowContainer.css("opacity", c), this.foldShadow.css({
                left: b,
                display: "block"
            })) : this.foldShadow.css("display", "none");
            c = this.calculateOpacity(2 * h, 2 * e, this.foldGradientThreshold, 50);
            this.foldGradient && 0 < c ? (b = d ? e - h : h - a.foldGradientWidth, this.foldGradientContainer.css({
                opacity: c,
                left: b,
                display: "block"
            })) : this.foldGradientContainer.css("display", "none")
        },
        animateFoldPage: function(a,
            c, b, e, f, g, h, l) {
            var k = this;
            if (!k.animating) {
                k.animating = !0;
                b || (b = a.data("holdedAt"));
                c || (c = a.data("holdedCorner"));
                var m = b.x - e.x,
                    n = b.y - e.y,
                    p, r;
                void 0 == l && (l = this.turnPageDuration * Math.abs(m) / (2 * this.pageWidth));
                l < this.opts.turnPageDurationMin && (l = this.opts.turnPageDurationMin);
                !a.isHardPage && .4 < l / this.turnPageDuration && this.playFlipSound();
                this._animationData = {
                    from: b,
                    to: e,
                    dx: -m
                };
                this.holdPage(a, b.x, b.y, c, h);
                this._percent = 0;
                d(this).animate({
                    _percent: 1
                }, {
                    duration: l,
                    easing: "linear",
                    complete: function() {
                        k.animating = !1;
                        d.isFunction(f) && f()
                    },
                    step: function(e, d) {
                        p = b.x - e * m;
                        r = b.y - e * n;
                        g && (r -= (.5 - Math.abs(.5 - e)) * k.pageHeight / 10);
                        k.holdPage(a, p, r, c, h)
                    }
                })
            }
        },
        stopAnimation: function(a) {
            arguments.length || (a = !0);
            d(this).stop(!0, a);
            this.animating = !1;
            this.currentFlip && (this.currentFlip.finished = !0)
        },
        flip: function(a, c, b, e) {
            e || (e = d.isPlainObject(a) ? a : {});
            e.from || (e.from = []);
            e.to || (e.to = []);
            var f = this;
            if (!f.animating) {
                f.animating = !0;
                b || (b = e.page || f.holdedPage);
                var g = b.data("holded_info");
                b.data("holdedAt");
                var h = e.corner || b.data("holdedCorner"),
                    l = d.easing[e.easing] || e.easing || function(a) {
                        return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
                    };
                a = {
                    page: b,
                    back: e.back || f.holdedPageBack || f.backPage(b.pageIndex),
                    initialX: void 0 != e.from[0] ? e.from[0] : g[0],
                    initialY: void 0 != e.from[1] ? e.from[1] : g[1],
                    finalX: void 0 != e.to[0] ? e.to[0] : a,
                    finalY: void 0 != e.to[1] ? e.to[1] : c,
                    corner: h || g[2],
                    duration: e.duration,
                    complete: function() {
                        f.animating = !1;
                        d.isFunction(e.complete) && e.complete()
                    },
                    easing: l,
                    arc: e.arc,
                    dragging: e.dragging,
                    start: d.now(),
                    finished: !1
                };
                a.deltaX = a.finalX - a.initialX;
                a.deltaY =
                    a.finalY - a.initialY;
                this._animationData = {
                    from: {
                        x: a.initialX,
                        y: a.initialY
                    },
                    to: {
                        x: a.finalX,
                        y: a.finalY
                    },
                    dx: a.deltaX
                };
                void 0 == a.duration && (a.duration = this.turnPageDuration * Math.abs(a.deltaX) / (2 * this.pageWidth));
                a.duration < this.opts.turnPageDurationMin && (a.duration = this.opts.turnPageDurationMin);
                !b.isHardPage && .4 < a.duration / this.turnPageDuration && this.playFlipSound();
                this.currentFlip = a
            }
        },
        rafCallback: function() {
            window.raf(this.callRAFCallback);
            this._zoomUpdateOnRAF();
            if (this.currentFlip && !this.currentFlip.finished) {
                var a =
                    this.currentFlip,
                    c = (d.now() - a.start) / a.duration;
                1 <= c && (c = 1);
                a.x = a.initialX + a.deltaX * a.easing(c, a.duration * c, 0, 1, a.duration);
                a.y = a.initialY + a.deltaY * a.easing(c, a.duration * c, 0, 1, a.duration);
                a.arc && (a.y -= (.5 - Math.abs(.5 - a.easing(c, a.duration * c, 0, 1))) * this.pageHeight / 10);
                a.dragging && (a.x = a.initialX + .2 * a.deltaX, a.y = a.initialY + .2 * a.deltaY, a.initialX = a.x, a.initialY = a.y, a.deltaX = a.finalX - a.initialX, a.deltaY = a.finalY - a.initialY, 1 > a.deltaX && 1 > a.deltaY && 1 == c);
                this.holdPage(a.page, a.x, a.y, a.corner, a.back);
                1 ==
                    c && (a.finished = !0, a.complete && a.complete())
            }
        },
        releasePages: function() {
            for (var a = 0, c = this.pages.length; a < c; a++) this.pages[a].data("holded") && this.releasePage(a)
        },
        releasePage: function(a, c, b, e) {
            "number" === typeof a && (a = this.pages[a]);
            var d = this,
                g = a.data("holdedAt"),
                h = a.data("holdedCorner");
            if (c && g) this.flip({
                from: [g.x, g.y],
                to: this.corners[h],
                page: a,
                easing: "linear",
                duration: 1E4,
                duration: e,
                complete: function() {
                    d.releasePage(a)
                }
            });
            else if (c = a.data("pageIndex"), void 0 === b && (b = this.holdedPageBack || this.backPage(c)),
                this.holdedPageBack = this.holdedPage = null, a.data({
                    holded_info: null,
                    holdedAt: null,
                    holdedCorner: null,
                    grabPoint: !1,
                    foldPageBasic: null,
                    holded: !1
                }), this.clipBoundaries && !this.zoomed && (this.clipper.css("overflow", "hidden"), this.clipper.children(".wowbook-inner-clipper").css("overflow", "hidden")), this.shadowClipper.css("display", "none"), this.internalShadow.parent().hide(), this.foldGradientContainer.hide(), this.hardPageShadow.hide(), this.resetPage(a), b && b.length && (this.resetPage(b), b.hide()), this.foldShadow.removeClass("wowbook-shadow-fold-flipped").css({
                    transform: "",
                    left: ""
                }), this.foldGradientElem.removeClass("wowbook-fold-gradient-flipped").css("transform", ""), this.foldGradientContainer.css("transform", "").appendTo(this.pagesContainer), this.positionBookShadow(), this.opts.onReleasePage) this.opts.onReleasePage(this, c, a, b)
        },
        resetPage: function(a) {
            this._currentFlip = void 0;
            a.removeClass("wowbook-page-holded");
            this.resetCSS || (this.resetCSS = {
                transform: "",
                transformOrigin: "",
                clip: "auto",
                marginLeft: 0,
                marginTop: 0,
                filter: ""
            });
            var c = this.pageWidth,
                b = this.pageHeight;
            a.css(this.resetCSS).css({
                zIndex: a.data("zIndex"),
                width: c,
                height: b,
                left: this.pageIsOnTheLeft(a.data("pageIndex")) ? 0 : c
            });
            d.browser.msie && 9 > d.browser.version && a.attr("style", a.attr("style").replace(/clip\: [^;]+;/i, ""));
            a = d(".wowbook-page-content", a);
            a.css(this.resetCSS);
            k(a, c, b)
        },
        gotoPage: function(a, c) {
            var b, e;
            if (!this.animating && ("string" === typeof a && "#" == a.charAt(0) && (a = this.selectorToPage(a)), 0 > a && (a = 0), a > this.pages.length - 1 && (a = this.pages.length - 1), !this.isOnPage(a))) {
                this._cantStopAnimation = !0;
                var d = a < this.currentPage;
                b = this.rtl ? a > this.currentPage :
                    d;
                var g = this,
                    h = b ? g.leftPage() : g.rightPage();
                if (h) {
                    this.uncurl(!0);
                    var l, k;
                    b ? (l = this.leftPage(a), k = this.rightPage(a)) : (l = this.rightPage(a), k = this.leftPage(a));
                    var m = k && k.is(":visible");
                    if (d)
                        for (d = h.pageIndex - 1; 0 <= d; d--) this.pages[d].css("display", "none");
                    else
                        for (d = h.pageIndex + 1, e = this.pages.length; d < e; d++) this.pages[d].css("display", "none");
                    l && l.css("display", "block");
                    m && k.css("display", "block");
                    var n = a;
                    l = h.data("holdedAt");
                    m = h.data("holdedAt");
                    d = h.data("holdedCorner") || (b ? "tl" : "tr");
                    b ? (m = m || {
                        x: 0,
                        y: 0
                    }, b = 2 * g.pageWidth, e = "bl" != d ? 0 : this.pageHeight) : (m = m || {
                        x: this.pageWidth,
                        y: 0
                    }, b = -g.pageWidth, e = "br" != d ? 0 : this.pageHeight);
                    var p = "linear";
                    if (this.centeredWhenClosed && (h.isHardPage || k.isHardPage)) {
                        var r = this.pages.length - 1,
                            s = !this.rtl,
                            p = "easeOutCubic";
                        this.pageIsOnTheRight(this.currentPage) && !this.otherPage(this.currentPage) && (b += this.pageWidth / 2, a != (s ? r : 0) || this.otherPage(a) || (b += this.pageWidth / 2));
                        this.pageIsOnTheLeft(this.currentPage) && !this.otherPage(this.currentPage) && (b -= this.pageWidth / 2, a !=
                            (s ? 0 : r) || this.otherPage(a) || (b -= this.pageWidth / 2))
                    }
                    g.flip({
                        from: [m.x, m.y],
                        to: [b, e],
                        easing: p,
                        arc: !l,
                        page: h,
                        back: k,
                        corner: d,
                        complete: function() {
                            g._cantStopAnimation = !1;
                            g.releasePage(h, !1);
                            g.showPage(n, c)
                        }
                    });
                    return a
                }
            }
        },
        back: function() {
            return this.gotoPage(this.currentPage - 2)
        },
        advance: function() {
            return this.gotoPage(this.currentPage + 2)
        },
        leftPage: function(a) {
            void 0 === a && (a = this.currentPage);
            return this.pages[this.leftPageIndex(a)] || null
        },
        leftPageIndex: function(a) {
            if (null != a) {
                this.pageIsOnTheRight(a) &&
                    (a += this.rtl ? 1 : -1);
                if (0 > a || a > this.pages.length - 1) a = null;
                return a
            }
        },
        rightPage: function(a) {
            void 0 === a && (a = this.currentPage);
            return this.pages[this.rightPageIndex(a)] || null
        },
        rightPageIndex: function(a) {
            if (null != a) {
                this.pageIsOnTheLeft(a) && (a += this.rtl ? -1 : 1);
                if (0 > a || a > this.pages.length - 1) a = null;
                return a
            }
        },
        pageIsOnTheRight: function(a) {
            return !this.pageIsOnTheLeft(a)
        },
        pageIsOnTheLeft: function(a) {
            a = !(a % 2);
            this.closable && (a = !a);
            this.rtl && (a = !a);
            return a
        },
        otherPage: function(a) {
            var c = this.pageIsOnTheLeft(a) ?
                1 : -1;
            this.rtl && (c = -c);
            a += c;
            if (0 > a || a > this.pages.length - 1) a = null;
            return a
        },
        isOnPage: function(a) {
            return "number" === typeof a && (a === this.currentPage || a === this.otherPage(this.currentPage))
        },
        backPage: function(a) {
            if (!this.pages[a]) return null;
            var c = a % 2 ? 1 : -1;
            a += this.closable ? -c : c;
            return this.pages[a]
        },
        pageBelow: function(a) {
            a = parseInt(a, 10);
            if (a != a) return null;
            a += this.pageIsOnTheLeft(a) != this.rtl ? -2 : 2;
            if (0 > a || a > this.pages.length - 1) a = null;
            return a
        },
        pageType: function(a) {
            a = "number" === typeof a ? this.pages[a] : a;
            return a.isHardPage ? "hard" : a.find(".wowbook-page-content.wowbook-basic-page").length ? "basic" : "soft"
        },
        calculateOpacity: function(a, c, b, d) {
            if (a <= b || a >= c - b) return 0;
            if (a >= d && a <= c - d) return 1;
            a > d && (a = c - a);
            return (a - b) / (d - b)
        },
        startSlideShow: function() {
            this.slideShowRunning = !0;
            this.advanceAfterTimeout(this.slideShowDelay);
            d(this.opts.controls.slideShow).addClass("wowbook-disabled")
        },
        advanceAfterTimeout: function(a) {
            var c = this;
            this.slideShowTimer = setTimeout(function() {
                c.animating || c.holdedPage ? c.advanceAfterTimeout(100) :
                    (c.advance(), c.isOnPage(c.pages.length - 1) ? c.stopSlideShow() : c.advanceAfterTimeout(c.slideShowDelay + c.turnPageDuration))
            }, a)
        },
        stopSlideShow: function() {
            clearTimeout(this.slideShowTimer);
            this.slideShowTimer = void 0;
            this.slideShowRunning = !1;
            d(this.opts.controls.slideShow).removeClass("wowbook-disabled")
        },
        toggleSlideShow: function() {
            this.slideShowRunning ? this.stopSlideShow() : this.startSlideShow()
        },
        findSections: function(a) {
            a && (this.sectionDefinition = a);
            var c = this.sectionDefinition;
            a = [];
            var b;
            "string" === typeof c &&
                (b = c, c = [], d(b, this.elem).each(function(a, b) {
                    c.push(["#" + b.id, d(b).html()])
                }));
            if (d.isArray(c)) {
                for (var e = 0, f = c.length; e < f; e++) {
                    b = c[e];
                    if ("string" === typeof b) try {
                        b = [b, d(b, this.elem).html()]
                    } catch (g) {
                        continue
                    }
                    try {
                        b[2] = this.selectorToPage(b[0])
                    } catch (h) {
                        continue
                    }
                    void 0 !== b[2] && a.push({
                        id: b[0],
                        title: b[1],
                        page: b[2]
                    })
                }
                a = a.sort(function(a, b) {
                    return a.page - b.page
                })
            }
            return this.sections = a
        },
        pageToSection: function(a) {
            for (var c = this.sections, b, d = 0, f = c.length; d < f && !(c[d].page > a); d++) b = c[d];
            return b
        },
        currentSection: function() {
            return this.pageToSection(this.currentPage)
        },
        fillToc: function(a, c) {
            var b = d(a || this.opts.toc),
                e, f, g = "";
            if (0 !== b.length) {
                e = this.sections;
                "undefined" === typeof c && (c = this.opts.tocTemplate);
                c || (g = b.is("UL, OL") ? "<li>" : "<div>", c = '<a href="${link}">${section}</a>');
                for (var h = 0, l = e.length; h < l; h++) f = e[h], f = c.replace(/\$\{link\}/g, "#" + this.id + "/" + f.id.substr(1)).replace(/\$\{section\}/g, f.title).replace(/\$\{page\}/g, f.page), d(f).appendTo(b).wrap(g)
            }
        },
        locationHashToPage: function(a, c) {
            void 0 === a && (a = window.location.hash);
            if (a == "#" + this.id + "/") return 0;
            a = a.slice(1).split("/");
            if (a[0] === this.id) {
                if (1 === a.length) return 0;
                var b = parseInt(a[1]);
                if (!isNaN(b)) return Math.max(b - 1, 0);
                b = this.selectorToPage("#" + a[1]);
                if (void 0 === b) return 0;
                isNaN(a[2]) || (b += Math.max(parseInt(a[2]) - 1, 0));
                return +b
            }
        },
        pageToLocationHash: function(a) {
            var c = "",
                b = a + 1;
            if (a = this.pageToSection(a)) c += "/" + a.id.replace("#", ""), b -= a.page;
            1 < b && (c += "/" + b);
            return "#" + this.id + (c || "/")
        },
        selectorToPage: function(a) {
            a = d(a, this.elem).closest(".wowbook-page");
            if (a.length) return +a.data("pageIndex")
        },
        getLocationHash: function() {
            return window.location.hash.slice(1)
        },
        locationEndsInHash: function(a) {
            void 0 === a && (a = window.location.href);
            return a.lastIndexOf("#") == a.length - 1
        },
        zoomSetup: function() {
            this._zoomOffset = {
                dx: 0,
                dy: 0
            };
            this._cssZoom = this._cssZoom || 1;
            this.zoomLevel = 1;
            this.detectBestZoomMethod();
            this._isMobile = d.wowBook.utils.isMobile();
            this.zoomTouchSupport();
            this.toggleControl("zoomIn", this.zoomLevel == this.zoomMax);
            this.toggleControl("zoomOut", this.zoomLevel == this.zoomMin);
            this.toggleControl("zoomReset",
                1 == this.zoomLevel)
        },
        _zoomUpdateOnRAF: function() {
            if (this._zoomDataRAF) {
                var a = d.extend({}, this._zoomDataRAF.options),
                    c = this._zoomDataRAF.options.offset;
                if (c) {
                    var b = this._zoomOffset,
                        e = c.dx - b.dx,
                        f = c.dy - b.dy;
                    a.offset = {
                        dx: b.dx + .2 * e,
                        dy: b.dy + .2 * f
                    }
                }
                b = this._zoomDataRAF.level || this.zoomLevel;
                b != this.zoomLevel && (b = this.zoomLevel + .2 * (b - this.zoomLevel));
                a.transform = !0;
                this._zoom(b, a);
                c && 1 > Math.abs(e) && 1 > Math.abs(f) && 1 > Math.abs(this.zoomLevel - b) && (this._zoomDataRAF.callback && this._zoomDataRAF.callback.call(this),
                    this._zoomDataRAF = null)
            }
        },
        _zoom: function(a, c) {
            c || (c = {});
            var b = void 0 != c.x ? c.x : this.pageWidth * this.currentScale,
                e = c.y || 0;
            this._zoomOffset = c.offset || this.zoomFocusOffset(a, b, e);
            this.zoomLevel = a;
            var b = c.transform || this.opts.zoomUsingTransform,
                f = a * this.currentScale,
                e = d.browser.ie7 ? 1 : b ? this._cssZoom : f,
                g = this.zoomWindow,
                h = this.zoomContent,
                l = d(this.zoomBoundingBox),
                k = l.outerWidth(),
                m = l.outerHeight(),
                n = g.offset();
            g.position();
            l = l[0] !== window ? l.offset() : {
                left: l.scrollLeft(),
                top: l.scrollTop()
            };
            g.css({
                width: k,
                height: m
            });
            k = l.left - n.left;
            n = l.top - n.top;
            k && (g.css("marginLeft", k), h.marginLeft = k);
            n && (g.css("marginTop", n), h.marginTop = n);
            g = "";
            n = this._zoomOffset.dx / e;
            k = this._zoomOffset.dy / e;
            d.wowBook.support.transform && (n || k) ? g = d.wowBook.utils.translate(n, k) : h.css({
                left: n,
                top: k
            });
            b ? (f /= e, g += this.opts.useScale3d ? "scale3d(" + f + "," + f + ",1)" : "scale(" + f + ")") : (this._cssZoom = f, h.css("zoom", f), h.css("marginLeft", -h.marginLeft / e), h.css("marginTop", -h.marginTop / e));
            d.wowBook.support.transform && h.css("transform", g);
            1 !== this.zoomLevel ?
                this.zoomed || (h.css("marginLeft", -h.marginLeft / e), h.css("marginTop", -h.marginTop / e), b && h.css("transformOrigin", "0 0")) : this.zoomFinished();
            this.zoomed = 1 !== a;
            h.toggleClass("wowbook-draggable", this.zoomed);
            this.toggleControl("zoomIn", this.zoomLevel == this.zoomMax);
            this.toggleControl("zoomOut", this.zoomLevel == this.zoomMin);
            this.toggleControl("zoomReset", 1 == this.zoomLevel)
        },
        zoom: function(a, c, b) {
            this.uncurl(!0);
            for (var e = 0, f = this.pages.length; e < f; e++)
                if (this.pages[e].data("holdedAt")) return;
            d.isPlainObject(c) &&
                (b = c, c = b.duration);
            b || (b = {});
            if (a <= this.zoomMin && !b.resetting) return this.zoomReset(c, b);
            a > this.zoomMax && (a = this.zoomMax);
            if (a !== this.zoomLevel || b.force)
                if (void 0 == c && (c = this.opts.zoomDuration), 0 == c) {
                    if (this._zoom(a, b), b.callback && b.callback.apply(this), this.onZoom) this.onZoom(this)
                } else {
                    e = !this.opts.zoomUsingTransform && d.wowBook.support.transform;
                    this._zoomAnimating && (d(this).stop(), e && this.zoomContent.css("transform", ""));
                    this._zoomAnimating = this.zoomLevel;
                    var g = this,
                        f = void 0 != b.x ? b.x : this.pageWidth *
                        this.currentScale,
                        h = b.y || 0;
                    o = {
                        x: f,
                        y: h,
                        offset: {
                            dx: 0,
                            dy: 0
                        }
                    };
                    initialOffset = d.extend({
                        dx: 0,
                        dy: 0
                    }, this._zoomOffset);
                    finalOffset = b.offset || this.zoomFocusOffset(a, f, h);
                    dx = finalOffset.dx - initialOffset.dx;
                    dy = finalOffset.dy - initialOffset.dy;
                    e && (o.transform = !0, this._isMobile && (this.leftPage() && this.leftPage().css("-webkit-transform", "translateZ(0)"), this.rightPage() && this.rightPage().css("-webkit-transform", "translateZ(0)")));
                    d(this).animate({
                        _zoomAnimating: a
                    }, {
                        duration: c,
                        easing: b.easing || this.opts.zoomEasing,
                        complete: function() {
                            g._zoomAnimating = !1;
                            g._zoom(a);
                            b.callback && b.callback.apply(this);
                            if (g.onZoom) g.onZoom(g)
                        },
                        step: function(a, b) {
                            o.offset.dx = initialOffset.dx + dx * b.pos;
                            o.offset.dy = initialOffset.dy + dy * b.pos;
                            g._zoom(a, o)
                        }
                    })
                }
        },
        zoomFinished: function() {
            this.zoomWindow.css({
                overflow: "visible",
                width: this.zoomContent.width() * this.currentScale,
                height: this.zoomContent.height() * this.currentScale,
                marginLeft: 0,
                marginTop: 0
            });
            this.zoomContent.css({
                left: 0,
                top: 0,
                marginLeft: 0,
                marginTop: 0
            });
            this._zoomOffset = {
                dx: 0,
                dy: 0
            }
        },
        zoomReset: function(a, c) {
            d.isPlainObject(a) && (c = a, a = c.duration);
            c || (c = {});
            this._zoomDataRAF = null;
            c.offset = {
                dx: 0,
                dy: 0
            };
            c.resetting = !0;
            c.force = !0;
            c.callback = function() {
                this.zoomContent.css({
                    left: 0,
                    top: 0
                });
                this.zoomed = !1
            };
            this.zoom(1, a, c)
        },
        zoomIn: function(a, c) {
            d.isPlainObject(a) && (c = a, a = void 0);
            this.zoom(this.zoomLevel + (a || this.zoomStep), c)
        },
        zoomOut: function(a, c) {
            d.isPlainObject(a) && (c = a, a = void 0);
            this.zoom(this.zoomLevel - (a || this.zoomStep), c)
        },
        zoomFocusOffset: function(a, c, b, e, f) {
            e || (e = this._zoomOffset || {
                dx: 0,
                dy: 0
            });
            e = d.extend({
                dx: 0,
                dy: 0
            }, e);
            var g = e.dx || 0,
                h = e.dy || 0;
            f = a / (f || this.zoomLevel);
            c -= g;
            b -= h;
            a = c * f;
            f *= b;
            e.dx = g - (a - c);
            e.dy = h - (f - b);
            return {
                dx: g - (a - c),
                dy: h - (f - b)
            }
        },
        zoomTouchSupport: function() {
            if (this.opts.touchEnabled) {
                if (d.browser.ie8mode || d.browser.ie7) return this.zoomDragSupportForIE();
                var a = this,
                    c, b, e;
                a._hammer = a.zoomContent.hammer(a.opts.touch).on("touch.wowbook", function(b) {
                    a.zoomContent.addClass("wowbook-dragging")
                }).on("release.wowbook", function(c) {
                    0 == c.gesture.changedLength && (a.zoomContent.removeClass("wowbook-dragging"),
                        c = a.zoomLevel, b = e = null, c < a.zoomMin || c == a.zoomMin && (a._zoomOffset.dx || a._zoomOffset.dy) ? a.zoomReset() : a._zoom(c, {
                            force: !0,
                            offset: a._zoomOffset
                        }))
                }).on("drag.wowbook dragstart.wowbook dragend.wowbook", function(c) {
                    if (a.zoomed) {
                        var g = c.gesture;
                        if (g) {
                            e = null;
                            var h = g.touches[0].identifier;
                            b && h == b.touchId || (b = {
                                touchId: h,
                                offset: d.extend({}, a._zoomOffset),
                                pageX: g.center.pageX,
                                pageY: g.center.pageY
                            });
                            "dragend" == c.type ? b = null : (a._zoomDataRAF = {
                                level: a.zoomLevel,
                                options: {
                                    force: !0,
                                    offset: {
                                        dx: b.offset.dx + (g.center.pageX -
                                            b.pageX),
                                        dy: b.offset.dy + (g.center.pageY - b.pageY)
                                    }
                                }
                            }, g.preventDefault())
                        }
                    }
                });
                if (a.opts.pinchToZoom) a._hammer.on("pinch.wowbook transformstart.wowbook transformend.wowbook", function(f) {
                    var g = f.gesture;
                    if (g) {
                        b = null;
                        var h = g.center.pageX,
                            k = g.center.pageY;
                        if (!e) {
                            if (a.currentFlip && !a.currentFlip.finished) {
                                f.preventDefault && f.preventDefault();
                                g.preventDefault && g.preventDefault();
                                return
                            }
                            c = a.elem.offset();
                            e = {
                                level: a.zoomLevel,
                                pageX: h,
                                pageY: k,
                                x: h - c.left,
                                y: k - c.top,
                                offset: d.extend({}, a._zoomOffset),
                                useTransform: a.opts.zoomUsingTransform
                            }
                        }
                        if ("transformend" ==
                            f.type) e = null;
                        else {
                            f = e.level * g.scale;
                            f > a.zoomMax && (f = a.zoomMax);
                            var m = a.zoomFocusOffset(f, e.x, e.y, e.offset, e.level);
                            m.dx += h - e.pageX;
                            m.dy += k - e.pageY;
                            a._zoomDataRAF = {
                                level: f,
                                options: {
                                    force: !0,
                                    offset: m
                                }
                            };
                            g.preventDefault()
                        }
                    }
                })
            }
        },
        zoomDragSupportForIE: function() {
            var a = this,
                c, b = function(b) {
                    a._zoomDataRAF = {
                        level: a.zoomLevel,
                        options: {
                            force: !0,
                            offset: {
                                dx: c.offset.dx + (b.pageX - c.pageX),
                                dy: c.offset.dy + (b.pageY - c.pageY)
                            }
                        }
                    };
                    return !1
                },
                e = function(c) {
                    c = a.zoomLevel;
                    (c < a.zoomMin || c == a.zoomMin && (a._zoomOffset.dx || a._zoomOffset.dy)) &&
                    a.zoomReset();
                    d(document).unbind("mousemove.wowbook", b);
                    d(document).unbind("mouseup.wowbook", e)
                };
            a.zoomContent.bind("mousedown.wowbook", function(f) {
                if (a.zoomed) return c = {
                    offset: d.extend({}, a._zoomOffset),
                    pageX: f.pageX,
                    pageY: f.pageY
                }, d(document).bind("mousemove.wowbook", b).bind("mouseup.wowbook", e), !1
            })
        },
        detectBestZoomMethod: function(a, c, b) {
            void 0 === a && (a = d.wowBook.support.transform);
            void 0 === b && (b = d.browser.ie8mode);
            a = d.browser.chrome || d.browser.webkit || d.browser.safari || d.browser.opera || b || !a;
            this.opts.zoomUsingTransform = !a;
            return a ? "zoom" : "transform"
        },
        setupFullscreen: function() {
            if (B) {
                var a = this,
                    c, b = "fullscreenerror mozfullscreenerror webkitfullscreenerror MSFullscreenError ";
                c = "fullscreenchange mozfullscreenchange webkitfullscreenchange MSFullscreenChange ".replace(/ /g, ".wowbook ");
                b = b.replace(/ /g, ".wowbook ");
                this._fullscreenChangeHandler = function() {
                    var b = n.fullscreenElement || n.mozFullScreenElement || n.webkitFullscreenElement || n.msFullscreenElement;
                    d(a.opts.fullscreenElement).toggleClass("fullscreen", b);
                    a.elem.toggleClass("fullscreen",
                        b);
                    a.toggleControl("fullscreen", b)
                };
                d(document).on(c, this._fullscreenChangeHandler);
                this._fullscreenErrorHandler = function() {
                    a.opts.onFullscreenError && a.opts.onFullscreenError.apply(this, arguments)
                };
                d(document).on(b, this._fullscreenErrorHandler)
            } else d(this.opts.controls.fullscreen).hide()
        },
        enterFullscreen: function(a) {
            a = d(a || this.opts.fullscreenElement);
            a.addClass("wowbook-fullscreen-fix");
            a = d(a || this.opts.fullscreenElement)[0];
            B.call(a || s)
        },
        exitFullscreen: function() {
            d(this.opts.fullscreenElement).removeClass("wowbook-fullscreen-fix");
            A.call(n)
        },
        toggleFullscreen: function() {
            n.fullscreenElement || n.mozFullScreenElement || n.webkitFullscreenElement || n.msFullscreenElement ? this.exitFullscreen() : this.enterFullscreen()
        },
        positionBookShadow: function() {
            var a = this.pages.length,
                c = !(!this.opts.bookShadow || !a || 3 > a && this.holdedPage);
            this.bookShadow.toggle(c);
            if (c) {
                var c = this.pageWidth,
                    b = this.holdedPageBack,
                    d = !!b && b.onRight && b.pageIndex == (this.rtl ? a - 1 : 0),
                    a = !!b && b.onLeft && b.pageIndex == (this.rtl ? 0 : a - 1);
                noPageOnLeft = !this.leftPage() || d;
                noPageOnRight = !this.rightPage() || a;
                onePageVisible = noPageOnLeft != noPageOnRight;
                noPageOnLeft && noPageOnRight ? this.bookShadow.hide() : (a = this.opts.zoomUsingTransform ? this.currentScale * this.zoomLevel : 1, d = this.elem.is(":visible") ? this.pagesContainer.position().left : parseFloat(this.pagesContainer.css("left")) || 0, this.bookShadow.css({
                    left: (noPageOnLeft ? c : 0) + d / a,
                    width: onePageVisible ? c : 2 * c
                }))
            }
        },
        playFlipSound: function() {
            if (this.flipSound) {
                var a = this.opts.onPlayFlipSound;
                d.isFunction(a) && !1 === a(this) || (this.audio || (this.audio =
                    this.createAudioPlayer()), this.audio && this.audio.play && this.audio.play())
            }
        },
        toggleFlipSound: function(a) {
            arguments.length || (a = !this.flipSound);
            this.flipSound = a;
            this.toggleControl("flipSound", !a)
        },
        createAudioPlayer: function(a, c) {
            a || (a = this.opts.flipSoundPath);
            c || (c = this.opts.flipSoundFile);
            for (var b = [], e = 0, f = c.length; e < f; e++) b.push('<source src="' + a + c[e] + '">');
            return d("<audio preload>" + b.join("") + "</audio>")[0]
        },
        _untouch: function(a) {
            return a.originalEvent.touches && a.originalEvent.touches[0] || a
        },
        touchSupport: function() {
            var a =
                this;
            a.elem.bind("touchstart.wowbook", function(c) {
                var b = c.originalEvent.touches;
                1 < b.length || (a._touchStarted = {
                    x: b[0].pageX,
                    y: b[0].pageY,
                    timestamp: c.originalEvent.timeStamp,
                    inHandle: d(c.target).hasClass("wowbook-handle")
                }, a._touchStarted.inHandle && a.pageEdgeDragStart(a._untouch(c)))
            });
            d(document).on("touchmove.wowbook", function(c) {
                if (a._touchStarted) {
                    var b = c.originalEvent.touches;
                    a._touchEnded = {
                        x: b[0].pageX,
                        y: b[0].pageY,
                        timestamp: c.originalEvent.timeStamp
                    };
                    if (a._touchStarted.inHandle) return a.pageEdgeDrag(a._untouch(c));
                    a.opts.allowDragBrowserPageZoom && 1 != document.documentElement.clientWidth / window.innerWidth || c.preventDefault()
                }
            });
            d(document).on("touchend.wowbook touchcancel.wowbook", function(c) {
                if (a._touchStarted) {
                    !a._touchEnded && d(c.target).hasClass("wowbook-handle") && (c = d(c.target).data("corner"), "r" === c && a.advance(), "l" === c && a.back());
                    var b = a._touchStarted,
                        e = a._touchEnded || a._touchStarted;
                    a._touchStarted = null;
                    a._touchEnded = null;
                    if (!a.zoomed) {
                        if (b.inHandle) return a.pageEdgeDragStop({
                            pageX: e.x
                        }), !1;
                        c = e.x - b.x;
                        var f = e.y - b.y,
                            b = e.timestamp - b.timestamp;
                        if (!(20 > Math.abs(c) || 200 < b) && Math.abs(c) > Math.abs(f)) return 0 > c ? a.advance() : a.back(), !1
                    }
                }
            })
        },
        pageEdgeDragStart: function(a) {
            if (!this.zoomed) {
                if (this.animating && !this.curledPage || !d(a.target).hasClass("wowbook-handle")) return !1;
                var c = this,
                    b = c.elem.offset();
                c.elem.addClass("wowbook-unselectable");
                c.mouseDownAtLeft = (a.pageX - b.left) / this.currentScale < c.pageWidth;
                c.pageGrabbed = c.mouseDownAtLeft ? c.leftPage() : c.rightPage();
                if (!c.pageGrabbed) return !1;
                this.uncurl(!0);
                c.pageGrabbedOffset = c.pageGrabbed.offset();
                c._dragging = !0;
                this.opts.zoomUsingTransform && (c.pageGrabbedOffset.left /= this.currentScale, c.pageGrabbedOffset.top /= this.currentScale);
                b = a.pageX / this.currentScale - this.pageGrabbedOffset.left;
                a = a.pageY / this.currentScale - this.pageGrabbedOffset.top;
                this.stopAnimation(!1);
                var e = c.mouseDownAtLeft ? "l" : "r";
                this.holdPage(this.pageGrabbed, b, a);
                this.flip(b, a, this.pageGrabbed, {
                    corner: e
                });
                d(document).bind("mousemove.wowbook", function(a) {
                    return c.pageEdgeDrag(a)
                }).bind("mouseup.wowbook",
                    function(a) {
                        return c.pageEdgeDragStop(a)
                    });
                return !1
            }
        },
        pageEdgeDrag: function(a) {
            if (!this._dragging) return !1;
            var c = a.pageX / this.currentScale - this.pageGrabbedOffset.left;
            a = a.pageY / this.currentScale - this.pageGrabbedOffset.top;
            var b = this.mouseDownAtLeft ? "l" : "r";
            this.stopAnimation(!1);
            this.flip(c, a, this.pageGrabbed, {
                corner: b,
                dragging: !0
            });
            return !1
        },
        pageEdgeDragStop: function(a) {
            if (!this._dragging) return !1;
            var c = this.elem.offset();
            a = (a.pageX - c.left) / this.currentScale < this.pageWidth;
            this.elem.removeClass("wowbook-unselectable");
            this._cantStopAnimation || this.stopAnimation(!1);
            this.mouseDownAtLeft && !a ? this.rtl ? this.advance() : this.back() : !this.mouseDownAtLeft && a ? this.rtl ? this.back() : this.advance() : this.releasePage(this.pageGrabbed, !0);
            this._dragging = !1;
            d(document).unbind("mousemove.wowbook mouseup.wowbook")
        },
        curl: function(a, c) {
            if (!(this.curledPage || this.holdedPage || this.zoomed)) {
                void 0 == a && (a = this.currentPage);
                if ("number" == typeof a || "string" == typeof a) a = this.pages[+a];
                if (a && !a.isCurled) {
                    a.isCurled = !0;
                    this.curledPage = a;
                    var b =
                        this.pageIsOnTheLeft(a.pageIndex),
                        d = b ? 0 : this.pageWidth,
                        f = c ? this.pageHeight - 1 : 2;
                    this.flip({
                        from: [d, f],
                        to: [d + this.opts.curlSize * (b ? 1 : -1), f + this.opts.curlSize * (c ? -1 : 1)],
                        corner: (c ? "b" : "t") + (b ? "l" : "r"),
                        page: a,
                        duration: 400
                    })
                }
            }
        },
        uncurl: function(a, c) {
            if (this.curledPage) {
                1 == a && (c = !0, a = void 0);
                void 0 == a && (a = this.curledPage || this.currentPage);
                if ("number" == typeof a || "string" == typeof a) a = this.pages[+a];
                a.isCurled && (this.stopAnimation(!1), this.releasePage(a, !c, void 0, 400), a.isCurled = !1, this.curledPage = null)
            }
        },
        initThumbnails: function() {
            var a = this.opts;
            this.thumbnails = [];
            var c = this.thumbnailsContainer = d("<div class='wowbook-thumbnails'>").append("<div class='wowbook-wrapper'><div class='wowbook-back wowbook-button' /><div class='wowbook-clipper'><ul></ul></div><div class='wowbook-next wowbook-button' /></div>").css("display", "none").css("transform", "translateZ(0)").appendTo(d(a.thumbnailsParent));
            this.thumbnailsList = c.find("ul");
            this.thumbnailsClipper = c.find(".wowbook-clipper");
            a.thumbnailsContainerWidth &&
                c.width(a.thumbnailsContainerWidth);
            a.thumbnailsContainerHeight && c.height(a.thumbnailsContainerHeight);
            var b = a.thumbnailsPosition;
            if ("left" == b || "right" == b) a.thumbnailsVertical = !0, "right" == b && c.css({
                position: "absolute",
                left: "auto",
                right: "0px"
            });
            if ("top" == b || "bottom" == b) a.thumbnailsVertical = !1, "bottom" == b && c.css({
                position: "absolute",
                top: "auto",
                bottom: "0px"
            });
            c.addClass(a.thumbnailsVertical ? "wowbook-vertical" : "wowbook-horizontal");
            c.toggleClass("wowbook-closable", this.closable);
            var e = this,
                f = a.thumbnailsVertical ?
                "height" : "width";
            this.thumbnailsBackButton = c.find(".wowbook-back.wowbook-button").click(function() {
                e._moveThumbnailsList(e.thumbnailsClipper[f]())
            });
            this.thumbnailsNextButton = c.find(".wowbook-next.wowbook-button").click(function() {
                e._moveThumbnailsList(-e.thumbnailsClipper[f]())
            });
            this.thumbnailsClipper.css("transform", "translateZ(0)")
        },
        destroyThumbnails: function() {
            this.thumbnailsContainer && this.thumbnailsContainer.remove();
            this.thumbnails = this.thumbnailsContainer = null
        },
        createThumbnails: function() {
            this.thumbnails ||
                this.initThumbnails();
            var a, c = this.thumbnailConfig();
            this.thumbnails = [];
            for (var b = 0, d = this.pages.length; b < d; b++) a = this.createThumbnail(b, c), this.thumbnailsList.append(a), this.thumbnails.push(a);
            if (this.rtl)
                for (a = this.thumbnailsList.children(), a.eq(0).addClass("wowbook-right").removeClass("wowbook-left"), b = 1, d = a.length; b < d; b += 2) a.eq(b).insertAfter(a.eq(b + 1));
            b = this.thumbnailsContainer;
            b.width() || b.width(2 * c.width)
        },
        thumbnailConfig: function() {
            var a = {},
                c = d('<div class="wowbook-thumbnail" style="display:none;position:absolute;line-height:0px;font-size:0px;">').prependTo(this.thumbnailsContainer),
                b = this.opts.thumbnailHeight || (2 >= c.height() ? 0 : c.height()),
                e = this.opts.thumbnailWidth || c.width(),
                f = e / this.pageWidth || b / this.pageHeight || this.opts.thumbnailScale;
            c.remove();
            a.width = e || this.pageWidth * f;
            a.height = b || this.pageHeight * f;
            a.cloneCSS = {
                display: "block",
                left: 0,
                top: 0,
                position: "relative",
                transformOrigin: "0 0"
            };
            d.wowBook.support.transform ? a.cloneCSS.transform = "scale(" + f + ")" : a.cloneCSS.zoom = f;
            return a
        },
        createThumbnail: function(a, c) {
            var b = this.pages[a];
            if (b) {
                c || (c = this.thumbnailConfig());
                var e = d('<li class="wowbook-thumbnail"><div class="wowbook-overlay">').addClass(this.pageIsOnTheLeft(a) ?
                    "wowbook-left" : "wowbook-right").css({
                    width: c.width,
                    height: c.height
                });
                this.opts.thumbnailsSprite ? e.css("background", "url(" + this.opts.thumbnailsSprite + ") no-repeat 0px -" + a * c.height + "px") : (b = b.clone(), b.hasClass("wowbook-page-holded") && (this.resetPage(b), b.find(".wowbook-fold-gradient-container").remove()), b.css(c.cloneCSS), e.prepend(b));
                var f = this;
                e.click(function() {
                    f.gotoPage(a)
                });
                return e
            }
        },
        updateThumbnail: function(a, c) {
            if (this.thumbnails) {
                var b = this.thumbnails[a];
                if (b) {
                    var d = this.createThumbnail(a,
                        c);
                    d && (this.opts.thumbnailsSprite || b.children(":not(.wowbook-overlay)").replaceWith(d.children(":not(.wowbook-overlay)")), b.width(d.width()), b.height(d.height()))
                }
            }
        },
        updateThumbnails: function() {
            if (this.thumbnails) {
                for (var a = this.thumbnailConfig(), c = 0, b = this.pages.length; c < b; c++) this.updateThumbnail(c, a);
                c = this.thumbnailsContainer;
                c.width() || c.width(2 * a.width);
                this.thumbnailsContainer.toggleClass("wowbook-closable", this.closable)
            } else this.createThumbnails()
        },
        _moveThumbnailsList: function(a, c) {
            var b =
                this.thumbnailsList.position()[this.opts.thumbnailsVertical ? "top" : "left"];
            this._setThumbnailsListPosition(b + a, c)
        },
        _setThumbnailsListPosition: function(a, c) {
            var b = this.opts.thumbnailsVertical,
                d = b ? "height" : "width",
                f = {},
                g = this.thumbnailsClipper[d](),
                d = -this.thumbnailsList[d]() + g;
            a < d && (a = d);
            0 < a && (a = 0);
            this.thumbnailsBackButton.toggleClass("wowbook-disabled", 0 == a || 0 < d);
            this.thumbnailsNextButton.toggleClass("wowbook-disabled", a == d || 0 < d);
            f[b ? "top" : "left"] = a;
            this.thumbnailsList.animate(f, void 0 != c ? c : this.opts.thumbnailsAnimOptions)
        },
        showThumbnail: function(a, c) {
            if (this.thumbnails && this.thumbnailsContainer.is(":visible")) {
                void 0 == a && (a = this.currentPage);
                0 < a && this.pageIsOnTheRight(a) && a--;
                var b = this.opts.thumbnailsVertical,
                    d = b ? "top" : "left",
                    f = b ? "height" : "width",
                    g = this.thumbnails[a],
                    h = this.thumbnailsClipper,
                    b = h[f]() / 2 - g[f]() / (b ? 2 : 1),
                    d = g.offset()[d] - h.offset()[d];
                this._moveThumbnailsList(b - d, c)
            }
        },
        showThumbnails: function(a) {
            this.thumbnails && this.thumbnails.length || this.createThumbnails();
            this.thumbnailsContainer.fadeIn(void 0 != a ? a :
                this.opts.thumbnailsAnimOptions);
            this.showThumbnail(void 0, 0)
        },
        hideThumbnails: function(a) {
            this.thumbnailsContainer.fadeOut(void 0 != a ? a : this.opts.thumbnailsAnimOptions)
        },
        toggleThumbnails: function(a) {
            d(this.thumbnailsContainer).is(":visible") ? this.hideThumbnails(a) : this.showThumbnails(a)
        },
        controllify: function(a) {
            var c = this;
            d(a.zoomIn).on("click.wowbook", function() {
                c.zoomIn({});
                return !1
            });
            d(a.zoomOut).on("click.wowbook", function() {
                c.zoomOut({});
                return !1
            });
            d(a.zoomReset).on("click.wowbook", function() {
                c.zoomReset({});
                return !1
            });
            d(a.next).on("click.wowbook", function() {
                c.advance();
                return !1
            });
            d(a.back).on("click.wowbook", function() {
                c.back();
                return !1
            });
            d(a.first).on("click.wowbook", function() {
                c.gotoPage(0);
                return !1
            });
            d(a.last).on("click.wowbook", function() {
                c.gotoPage(c.pages.length - 1);
                return !1
            });
            d(a.slideShow).on("click.wowbook", function() {
                c.toggleSlideShow();
                return !1
            });
            d(a.flipSound).on("click.wowbook", function() {
                c.toggleFlipSound();
                return !1
            });
            d(a.thumbnails).on("click.wowbook", function() {
                c.toggleThumbnails();
                return !1
            });
            d(a.fullscreen).on("click.wowbook", function() {
                c.toggleFullscreen();
                return !1
            })
        },
        toggleControl: function(a, c) {
            (a = this.opts.controls[a]) && d(a).toggleClass("wowbook-disabled", c)
        }
    };
    d.wowBook.defaults = {
        width: 500,
        height: 300,
        startPage: 0,
        hardcovers: !1,
        hardPages: !1,
        closable: !0,
        centeredWhenClosed: !1,
        doublePages: ".double",
        rtl: !1,
        responsive: !1,
        scaleToFit: "",
        onResize: null,
        fullscreenElement: document.documentElement,
        onFullscreenError: null,
        use3d: !0,
        perspective: 2E3,
        useTranslate3d: "mobile",
        useScale3d: !0,
        bookShadow: !0,
        gutterShadow: !0,
        shadowThreshold: 20,
        shadows: !0,
        foldGradient: !0,
        foldGradientThreshold: 20,
        pageNumbers: !0,
        firstPageNumber: 1,
        numberedPages: !1,
        deepLinking: !0,
        updateBrowserURL: !0,
        curl: !0,
        curlSize: 40,
        slideShow: !1,
        slideShowDelay: 1E3,
        pauseOnHover: !0,
        touchEnabled: !0,
        mouseWheel: !1,
        handleWidth: !1,
        handleClickDuration: 300,
        turnPageDuration: 1E3,
        turnPageDurationMin: 300,
        forceBasicPage: !1,
        sections: ".wowbook-section",
        zoomLevel: 1,
        zoomMax: 2,
        zoomMin: 1,
        zoomBoundingBox: window,
        zoomStep: .05,
        zoomDuration: 200,
        zoomEasing: "linear",
        onZoom: null,
        pinchToZoom: !0,
        allowDragBrowserPageZoom: !1,
        flipSound: !0,
        flipSoundFile: ["page-flip.mp3", "page-flip.ogg"],
        flipSoundPath: "./file/",
        onPlayFlipSound: null,
        keyboardNavigation: {
            back: 37,
            advance: 39
        },
        clipBoundaries: !0,
        controls: {},
        onShowPage: null,
        onHoldPage: null,
        onReleasePage: null,
        pagesInMemory: null,
        pagesToKeep: null,
        onLoadPage: null,
        onUnloadPage: null,
        thumbnails: !1,
        thumbnailsParent: "body",
        thumbnailScale: .2,
        thumbnailWidth: null,
        thumbnailHeight: null,
        thumbnailsPosition: null,
        thumbnailsVertical: !0,
        thumbnailsContainerWidth: null,
        thumbnailsContainerHeight: null,
        thumbnailsSprite: null,
        thumbnailsAnimOptions: {}
    };
    "undefined" != typeof QUnit && (d.wowBook.wowBook = p);
    window.raf = function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(a) {
            window.setTimeout(a, 1E3 / 60)
        }
    }();
    d.browser.ie8mode = d.browser.msie && 8 == document.documentMode;
    d.browser.ie7 = d.browser.msie && (7 == d.browser.version || 7 == document.documentMode);
    var m = d.browser.msie && 9 > d.browser.version ?
        1 : 0,
        w = {
            thin: 2 - m,
            medium: 4 - m,
            thick: 6 - m
        },
        n = window.document,
        s = n.documentElement,
        B = s.requestFullscreen || s.mozRequestFullScreen || s.webkitRequestFullscreen || s.msRequestFullscreen,
        A = n.exitFullscreen || n.mozCancelFullScreen || n.webkitExitFullscreen || n.msExitFullscreen;
    d.wowBook.utils = {
        translate: function(a, c, b) {
            return d.wowBook.useTranslate3d ? "translate3d(" + a + "px, " + c + "px, " + (b || 0) + "px) " : "translate(" + a + "px, " + c + "px) "
        },
        isMobile: function() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
        }
    }
})(jQuery);
(function(d) {
    function p(k) {
        var m = k || window.event,
            p = [].slice.call(arguments, 1),
            n = 0,
            s = 0,
            t = 0;
        k = d.event.fix(m);
        k.type = "mousewheel";
        m.wheelDelta && (n = m.wheelDelta / 120);
        m.detail && (n = -m.detail / 3);
        t = n;
        void 0 !== m.axis && m.axis === m.HORIZONTAL_AXIS && (t = 0, s = -1 * n);
        void 0 !== m.wheelDeltaY && (t = m.wheelDeltaY / 120);
        void 0 !== m.wheelDeltaX && (s = -1 * m.wheelDeltaX / 120);
        p.unshift(k, n, s, t);
        return (d.event.dispatch || d.event.handle).apply(this, p)
    }
    var t = ["DOMMouseScroll", "mousewheel"];
    if (d.event.fixHooks)
        for (var u = t.length; u;) d.event.fixHooks[t[--u]] =
            d.event.mouseHooks;
    d.event.special.mousewheel = {
        setup: function() {
            if (this.addEventListener)
                for (var d = t.length; d;) this.addEventListener(t[--d], p, !1);
            else this.onmousewheel = p
        },
        teardown: function() {
            if (this.removeEventListener)
                for (var d = t.length; d;) this.removeEventListener(t[--d], p, !1);
            else this.onmousewheel = null
        }
    };
    d.fn.extend({
        mousewheel: function(d) {
            return d ? this.bind("mousewheel", d) : this.trigger("mousewheel")
        },
        unmousewheel: function(d) {
            return this.unbind("mousewheel", d)
        }
    })
})(jQuery);
(function(d) {
    function p(k) {
        if (k in t.style) return d.wowBook.support[k] = k;
        for (var m = u.length, p, n = k.charAt(0).toUpperCase() + k.substr(1); m--;)
            if (p = u[m] + n, p in t.style) return d.wowBook.support[k] = p
    }
    if (d.cssHooks) {
        var t = document.createElement("div"),
            u = ["O", "ms", "Webkit", "Moz"];
        p("transform");
        p("transformOrigin");
        p("boxSizing");
        p("zoom");
        d.wowBook.support.boxSizing && 8 > document.documentMode && (d.wowBook.support.boxSizing = !1);
        t = null;
        d.each(["transform", "transformOrigin"], function(k, m) {
            d.wowBook.support[m] &&
                d.wowBook.support[m] !== m && !d.cssHooks[m] && (d.cssHooks[m] = {
                    get: function(k, n, p) {
                        return d.css(k, d.wowBook.support[m])
                    },
                    set: function(k, n) {
                        k.style[d.wowBook.support[m]] = n
                    }
                })
        });
        d.wowBook.applyAlphaImageLoader = function(k) {
            var m, p, n, s, t = "",
                u = d("<div style='display:none'></div>").appendTo("body");
            p = 0;
            for (n = k.length; p < n; p++)
                if (s = k[p], u.addClass(s), m = u.css("background-image").match(/^url\("(.*)"\)$/)) t += "." + s + "{background:none; filter : progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + m[1] + "', sizingMethod='scale'); } ",
                    u.removeClass(s);
            d("body").append("<style>" + t + "</style>")
        }
    } else alert("jQuery 1.4.3+ is needed for this plugin to work")
})(jQuery);